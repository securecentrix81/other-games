<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft - Secure Centrix81</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { overflow: hidden; background: #1a1a2e; font-family: 'Segoe UI', Arial, sans-serif; }
      #game-container { width: 100vw; height: 100vh; position: relative; }
      canvas { display: block; }

      #crosshair {
        position: fixed; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none; z-index: 100;
      }
      #crosshair::before, #crosshair::after {
        content: ''; position: absolute; background: white;
        mix-blend-mode: difference;
      }
      #crosshair::before { width: 2px; height: 24px; left: 11px; top: 0; }
      #crosshair::after { width: 24px; height: 2px; left: 0; top: 11px; }

      #hotbar {
        position: fixed; bottom: 10px; left: 50%;
        transform: translateX(-50%);
        display: flex; gap: 2px;
        background: rgba(0, 0, 0, 0.7);
        padding: 4px; border-radius: 4px;
        border: 2px solid #333; z-index: 100;
      }
      .hotbar-slot {
        width: 50px; height: 50px;
        border: 2px solid #1a1a1a;
        background: rgba(139, 139, 139, 0.3);
        display: flex; align-items: center; justify-content: center;
        position: relative; cursor: pointer;
        transition: all 0.1s;
      }
      .hotbar-slot.selected {
        border-color: #fff;
        background: rgba(200, 200, 200, 0.4);
        transform: scale(1.05);
      }
      .hotbar-slot canvas { image-rendering: pixelated; }
      .slot-number {
        position: absolute; top: 2px; left: 4px;
        color: #aaa; font-size: 10px; font-weight: bold;
        text-shadow: 1px 1px 1px #000;
      }
      .slot-count {
        position: absolute; bottom: 2px; right: 4px;
        color: #fff; font-size: 12px; font-weight: bold;
        text-shadow: 1px 1px 2px #000;
      }
      .slot-name {
        position: absolute; bottom: -18px; left: 50%;
        transform: translateX(-50%); white-space: nowrap;
        color: #fff; font-size: 11px;
        text-shadow: 1px 1px 2px #000;
        opacity: 0; transition: opacity 0.2s;
        pointer-events: none;
      }
      .hotbar-slot.selected .slot-name { opacity: 1; }

      #hud {
        position: fixed; top: 10px; left: 10px;
        color: white; font-size: 13px; z-index: 100;
        text-shadow: 2px 2px 2px rgba(0,0,0,0.8);
        background: rgba(0,0,0,0.3);
        padding: 10px; border-radius: 5px;
      }
      #hud div { margin: 3px 0; }

      #gamemode-indicator {
        position: fixed; top: 10px; right: 10px;
        color: white; font-size: 14px; z-index: 100;
        text-shadow: 2px 2px 2px rgba(0,0,0,0.8);
        background: rgba(0,0,0,0.5);
        padding: 8px 15px; border-radius: 5px;
        font-weight: bold;
      }
      #gamemode-indicator.creative { background: rgba(100, 200, 100, 0.5); }
      #gamemode-indicator.survival { background: rgba(200, 100, 100, 0.5); }

      /* Health Bar */
      #health-bar {
        position: fixed; bottom: 75px; left: 50%;
        transform: translateX(-50%);
        display: flex; gap: 2px;
        z-index: 100;
      }
      .heart {
        width: 18px; height: 18px;
        background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18"><path d="M9 16s-7-4.35-7-9A4 4 0 019 4a4 4 0 017 3c0 4.65-7 9-7 9z" fill="%23222" stroke="%23000" stroke-width="1"/></svg>');
        position: relative;
      }
      .heart-fill {
        position: absolute; top: 0; left: 0;
        width: 100%; height: 100%;
        background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18"><path d="M9 16s-7-4.35-7-9A4 4 0 019 4a4 4 0 017 3c0 4.65-7 9-7 9z" fill="%23e74c3c"/></svg>');
        clip-path: inset(0 0 0 0);
      }
      .heart-fill.half {
        clip-path: inset(0 50% 0 0);
      }
      .heart-fill.empty {
        opacity: 0;
      }

      #menu {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
        display: flex; flex-direction: column;
        align-items: center; justify-content: center;
        z-index: 200;
      }
      #menu.hidden { display: none; }

      #menu h1 {
        font-size: 72px; color: #4ade80;
        text-shadow: 4px 4px 0 #166534, 8px 8px 0 rgba(0,0,0,0.3);
        margin-bottom: 10px; letter-spacing: 4px;
      }
      #menu .subtitle {
        color: #888; font-size: 18px; margin-bottom: 40px;
      }
      #menu .controls {
        background: rgba(255,255,255,0.05);
        padding: 25px 40px; border-radius: 10px;
        margin-bottom: 30px; text-align: left;
      }
      #menu .controls p {
        color: #ccc; margin: 8px 0; font-size: 15px;
      }
      #menu .key {
        display: inline-block; background: #333;
        padding: 4px 12px; border-radius: 4px;
        color: #4ade80; min-width: 80px;
        text-align: center; margin-right: 10px;
        border: 1px solid #444;
      }
      #menu button {
        padding: 18px 60px; font-size: 22px;
        background: linear-gradient(180deg, #4ade80 0%, #22c55e 100%);
        color: #0a0a0a; border: none; border-radius: 8px;
        cursor: pointer; font-weight: bold;
        text-transform: uppercase; letter-spacing: 2px;
        transition: all 0.2s;
        box-shadow: 0 4px 0 #166534, 0 6px 10px rgba(0,0,0,0.3);
        margin: 5px;
      }
      #menu button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 0 #166534, 0 8px 15px rgba(0,0,0,0.3);
      }
      #menu button:active {
        transform: translateY(2px);
        box-shadow: 0 2px 0 #166534;
      }
      #menu button.secondary {
        background: linear-gradient(180deg, #666 0%, #444 100%);
        box-shadow: 0 4px 0 #222, 0 6px 10px rgba(0,0,0,0.3);
        padding: 12px 40px; font-size: 16px;
      }
      #menu button.secondary:hover {
        box-shadow: 0 6px 0 #222, 0 8px 15px rgba(0,0,0,0.3);
      }

      /* Settings Menu */
      #settings-panel {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.9);
        display: none; flex-direction: column;
        align-items: center; justify-content: center;
        z-index: 250;
      }
      #settings-panel.visible { display: flex; }
      #settings-panel h2 {
        color: #4ade80; font-size: 36px; margin-bottom: 30px;
      }
      .settings-container {
        background: rgba(50,50,50,0.8);
        padding: 30px 50px; border-radius: 10px;
        max-width: 500px; width: 90%;
      }
      .setting-row {
        display: flex; justify-content: space-between;
        align-items: center; margin: 15px 0;
        color: #fff;
      }
      .setting-row label { font-size: 16px; }
      .setting-row input[type="range"] {
        width: 150px; cursor: pointer;
      }
      .setting-row input[type="checkbox"] {
        width: 20px; height: 20px; cursor: pointer;
      }
      .setting-value {
        color: #4ade80; min-width: 50px; text-align: right;
        margin-left: 10px;
      }
      #settings-panel button {
        margin-top: 20px; padding: 12px 40px;
        font-size: 16px; background: #4ade80;
        color: #0a0a0a; border: none; border-radius: 5px;
        cursor: pointer; font-weight: bold;
      }

      /* Inventory */
      #inventory-screen {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8);
        display: none; flex-direction: column;
        align-items: center; justify-content: center;
        z-index: 150;
      }
      #inventory-screen.visible { display: flex; }
      #inventory-screen h2 {
        color: #fff; font-size: 24px; margin-bottom: 20px;
      }
      .inventory-container {
        background: #8b8b8b;
        padding: 10px; border-radius: 5px;
        border: 4px solid #373737;
      }
      .inventory-section {
        margin-bottom: 15px;
      }
      .inventory-section h3 {
        color: #404040; font-size: 14px; margin-bottom: 5px;
      }
      .inventory-grid {
        display: grid;
        grid-template-columns: repeat(9, 50px);
        gap: 2px;
      }
      .inv-slot {
        width: 50px; height: 50px;
        background: #8b8b8b;
        border: 2px solid;
        border-color: #373737 #fff #fff #373737;
        display: flex; align-items: center; justify-content: center;
        position: relative; cursor: pointer;
      }
      .inv-slot:hover { background: #aaa; }
      .inv-slot.selected { border-color: #4ade80; }
      .inv-slot canvas { image-rendering: pixelated; }
      .inv-slot .slot-count {
        position: absolute; bottom: 2px; right: 4px;
        color: #fff; font-size: 12px; font-weight: bold;
        text-shadow: 1px 1px 2px #000;
      }

      /* Crafting */
      #crafting-section {
        margin-top: 20px;
        background: #8b8b8b;
        padding: 15px; border-radius: 5px;
        border: 4px solid #373737;
      }
      #crafting-section h3 {
        color: #404040; font-size: 16px; margin-bottom: 10px;
        text-align: center;
      }
      .recipe-list {
        max-height: 200px;
        overflow-y: auto;
      }
      .recipe-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px;
        margin: 4px 0;
        background: #6b6b6b;
        border-radius: 4px;
        cursor: pointer;
      }
      .recipe-item:hover { background: #7b7b7b; }
      .recipe-item.can-craft { background: #5a8a5a; }
      .recipe-item.can-craft:hover { background: #6a9a6a; }
      .recipe-ingredients {
        display: flex; align-items: center; gap: 5px;
        color: #ddd; font-size: 12px;
      }
      .recipe-result {
        display: flex; align-items: center; gap: 5px;
        color: #fff; font-weight: bold;
      }
      .recipe-arrow { color: #fff; font-size: 18px; margin: 0 10px; }

      /* Tool durability bar */
      .durability-bar {
        position: absolute; bottom: 2px; left: 2px; right: 2px;
        height: 3px; background: #333;
        border-radius: 1px;
      }
      .durability-fill {
        height: 100%; background: #4ade80;
        border-radius: 1px;
        transition: width 0.1s;
      }

      #loading {
        position: fixed; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: white; font-size: 24px;
        z-index: 300; display: none;
      }
      #loading.show { display: block; }
      .spinner {
        width: 50px; height: 50px; margin: 20px auto;
        border: 4px solid #333; border-top-color: #4ade80;
        border-radius: 50%; animation: spin 1s linear infinite;
      }
      @keyframes spin { to { transform: rotate(360deg); } }

      #break-indicator {
        position: fixed; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none; z-index: 99;
        width: 64px; height: 64px;
        opacity: 0;
      }
      #break-indicator.active { opacity: 1; }
      #break-indicator-inner {
        width: 100%; height: 100%;
        border: 3px solid rgba(0,0,0,0.8);
        background: repeating-linear-gradient(
          45deg,
          transparent,
          transparent 4px,
          rgba(0,0,0,0.3) 4px,
          rgba(0,0,0,0.3) 8px
        );
        clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
      }
      
      #break-progress-bar {
        position: fixed; bottom: 80px; left: 50%;
        transform: translateX(-50%);
        width: 200px; height: 6px;
        background: rgba(0,0,0,0.5);
        border-radius: 3px;
        overflow: hidden;
        opacity: 0;
        transition: opacity 0.1s;
        z-index: 100;
      }
      #break-progress-bar.active { opacity: 1; }
      #break-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff6b6b, #ffa500);
        width: 0%;
        transition: width 0.05s linear;
      }

      /* Death screen */
      #death-screen {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(139, 0, 0, 0.7);
        display: none; flex-direction: column;
        align-items: center; justify-content: center;
        z-index: 200;
      }
      #death-screen.visible { display: flex; }
      #death-screen h1 {
        color: #fff; font-size: 48px; margin-bottom: 20px;
      }
      #death-screen button {
        padding: 15px 50px; font-size: 18px;
        background: #4ade80; color: #0a0a0a;
        border: none; border-radius: 5px;
        cursor: pointer; font-weight: bold;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div id="crosshair"></div>
      <div id="hotbar"></div>
      <div id="health-bar"></div>
      <div id="hud">
        <div id="position">XYZ: 0 / 0 / 0</div>
        <div id="fps">FPS: 0</div>
        <div id="chunk-info">Chunks: 0</div>
      </div>
      <div id="gamemode-indicator" class="survival">Survival</div>
      <div id="break-indicator"><div id="break-indicator-inner"></div></div>
      <div id="break-progress-bar"><div id="break-progress-fill"></div></div>

      <div id="menu">
        <h1>⛏ MINECRAFT</h1>
        <p class="subtitle">A Voxel Sandbox Adventure</p>
        <div class="controls">
          <p><span class="key">W A S D</span> Move around</p>
          <p><span class="key">SPACE</span> Jump / Fly up</p>
          <p><span class="key">SHIFT</span> Sprint / Fly down</p>
          <p><span class="key">MOUSE</span> Look around</p>
          <p><span class="key">LEFT CLICK</span> Break block</p>
          <p><span class="key">RIGHT CLICK</span> Place block</p>
          <p><span class="key">1 - 9</span> Select block</p>
          <p><span class="key">SCROLL</span> Cycle blocks</p>
          <p><span class="key">E</span> Open Inventory</p>
          <p><span class="key">C</span> Toggle Creative/Survival</p>
          <p><span class="key">ESC</span> Settings</p>
        </div>
        <button id="start-btn">Play World</button>
        <button id="settings-btn" class="secondary">Settings</button>
      </div>

      <div id="settings-panel">
        <h2>⚙ Settings</h2>
        <div class="settings-container">
          <div class="setting-row">
            <label>Render Distance</label>
            <input type="range" id="setting-render-distance" min="1" max="8" value="2">
            <span class="setting-value" id="render-distance-value">2</span>
          </div>
          <div class="setting-row">
            <label>Shadows Enabled</label>
            <input type="checkbox" id="setting-shadows">
          </div>
          <div class="setting-row" id="shadow-distance-row" style="display:none">
            <label>Shadow Distance</label>
            <input type="range" id="setting-shadow-distance" min="100" max="500" value="200">
            <span class="setting-value" id="shadow-distance-value">200</span>
          </div>
          <div class="setting-row">
            <label>FOV</label>
            <input type="range" id="setting-fov" min="60" max="120" value="80">
            <span class="setting-value" id="fov-value">80</span>
          </div>
          <div class="setting-row">
            <label>Mouse Sensitivity</label>
            <input type="range" id="setting-sensitivity" min="0.5" max="3" step="0.1" value="1">
            <span class="setting-value" id="sensitivity-value">1.0</span>
          </div>
          <div class="setting-row">
            <label>Fullscreen</label>
            <input type="checkbox" id="setting-fullscreen">
          </div>
        </div>
        <button id="settings-close-btn">Done</button>
      </div>

      <div id="inventory-screen">
        <h2>Inventory</h2>
        <div class="inventory-container">
          <div class="inventory-section">
            <h3>Inventory</h3>
            <div class="inventory-grid" id="main-inventory"></div>
          </div>
          <div class="inventory-section">
            <h3>Hotbar</h3>
            <div class="inventory-grid" id="hotbar-inventory"></div>
          </div>
        </div>
        <div id="crafting-section">
          <h3>Crafting</h3>
          <div class="recipe-list" id="recipe-list"></div>
        </div>
      </div>

      <div id="death-screen">
        <h1>You Died!</h1>
        <p style="color:#ddd;margin-bottom:20px;">Fell from a high place</p>
        <button id="respawn-btn">Respawn</button>
      </div>

      <div id="loading">
        <div class="spinner"></div>
        Generating World...
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script>let Q187235=true;addEventListener("error",(e)=>{if(Q187235){Q187235=false;alert(e.message)}})</script>
    <script>
      // ==================== CONSTANTS ====================
      const CHUNK_SIZE = 16;
      const WORLD_HEIGHT = 1000;
      const GRAVITY = 28;
      const JUMP_FORCE = 9;
      const PLAYER_HEIGHT = 1.62;
      const PLAYER_WIDTH = 0.6;
      const WALK_SPEED = 4.3;
      const SPRINT_SPEED = 5.6;
      const FLY_SPEED = 10;
      const WATER_LEVEL = 0;
      const PLACE_COOLDOWN = 0.3;
      const MAX_HEALTH = 20;
      const MAX_STACK_SIZE = 64;

      // Block types
      const BLOCK = {
        AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, WOOD: 4, LEAVES: 5,
        SAND: 6, WATER: 7, COBBLE: 8, PLANKS: 9, BEDROCK: 10,
        GRAVEL: 11, COAL_ORE: 12, IRON_ORE: 13, SNOW: 14, GLASS: 15,
        DIAMOND_ORE: 16, GOLD_ORE: 17, CRAFTING_TABLE: 18
      };

      // Item types (tools, materials, etc.)
      const ITEM = {
        // Raw materials (100-199)
        COAL: 100,
        IRON_INGOT: 101,
        GOLD_INGOT: 102,
        DIAMOND: 103,
        STICK: 104,
        
        // Pickaxes (200-209)
        WOODEN_PICKAXE: 200,
        STONE_PICKAXE: 201,
        IRON_PICKAXE: 202,
        DIAMOND_PICKAXE: 203,
        GOLD_PICKAXE: 204,
        
        // Axes (210-219)
        WOODEN_AXE: 210,
        STONE_AXE: 211,
        IRON_AXE: 212,
        DIAMOND_AXE: 213,
        
        // Shovels (220-229)
        WOODEN_SHOVEL: 220,
        STONE_SHOVEL: 221,
        IRON_SHOVEL: 222,
        DIAMOND_SHOVEL: 223,
        
        // Swords (230-239)
        WOODEN_SWORD: 230,
        STONE_SWORD: 231,
        IRON_SWORD: 232,
        DIAMOND_SWORD: 233
      };

      // Block data with hardness (time to break in seconds with hand)
      const BLOCK_DATA = {
        [BLOCK.GRASS]:    { name: 'Grass',       hardness: 0.9,  top: 0x7cba3d, side: 0x8b6914, bottom: 0x6b4423, solid: true, toolType: 'shovel' },
        [BLOCK.DIRT]:     { name: 'Dirt',        hardness: 0.75, top: 0x8b6914, side: 0x8b6914, bottom: 0x8b6914, solid: true, toolType: 'shovel' },
        [BLOCK.STONE]:    { name: 'Stone',       hardness: 7.5,  top: 0x7f7f7f, side: 0x7f7f7f, bottom: 0x7f7f7f, solid: true, toolType: 'pickaxe', minTool: 'wooden' },
        [BLOCK.WOOD]:     { name: 'Oak Log',     hardness: 2.0,  top: 0x9c7f4a, side: 0x5b3413, bottom: 0x9c7f4a, solid: true, toolType: 'axe' },
        [BLOCK.LEAVES]:   { name: 'Leaves',      hardness: 0.2,  top: 0x3d8c40, side: 0x3d8c40, bottom: 0x3d8c40, solid: true },
        [BLOCK.SAND]:     { name: 'Sand',        hardness: 0.75, top: 0xdbd3a0, side: 0xdbd3a0, bottom: 0xdbd3a0, solid: true, toolType: 'shovel' },
        [BLOCK.WATER]:    { name: 'Water',       hardness: -1,   top: 0x3498db, side: 0x3498db, bottom: 0x3498db, solid: false, transparent: true },
        [BLOCK.COBBLE]:   { name: 'Cobblestone', hardness: 10.0, top: 0x6a6a6a, side: 0x6a6a6a, bottom: 0x6a6a6a, solid: true, toolType: 'pickaxe', minTool: 'wooden' },
        [BLOCK.PLANKS]:   { name: 'Oak Planks',  hardness: 2.0,  top: 0xb8945f, side: 0xb8945f, bottom: 0xb8945f, solid: true, toolType: 'axe' },
        [BLOCK.BEDROCK]:  { name: 'Bedrock',     hardness: -1,   top: 0x333333, side: 0x333333, bottom: 0x333333, solid: true },
        [BLOCK.GRAVEL]:   { name: 'Gravel',      hardness: 0.9,  top: 0x7a7a7a, side: 0x7a7a7a, bottom: 0x7a7a7a, solid: true, toolType: 'shovel' },
        [BLOCK.COAL_ORE]: { name: 'Coal Ore',    hardness: 4.5,  top: 0x4a4a4a, side: 0x4a4a4a, bottom: 0x4a4a4a, solid: true, toolType: 'pickaxe', minTool: 'wooden', drops: ITEM.COAL },
        [BLOCK.IRON_ORE]: { name: 'Iron Ore',    hardness: 4.5,  top: 0x8a7560, side: 0x8a7560, bottom: 0x8a7560, solid: true, toolType: 'pickaxe', minTool: 'stone' },
        [BLOCK.SNOW]:     { name: 'Snow',        hardness: 0.15, top: 0xf0f0f0, side: 0xe8e8e8, bottom: 0xdedede, solid: true, toolType: 'shovel' },
        [BLOCK.GLASS]:    { name: 'Glass',       hardness: 0.45, top: 0xc8e8ff, side: 0xc8e8ff, bottom: 0xc8e8ff, solid: true, transparent: true, drops: null },
        [BLOCK.DIAMOND_ORE]: { name: 'Diamond Ore', hardness: 4.5, top: 0x4aedd9, side: 0x4aedd9, bottom: 0x4aedd9, solid: true, toolType: 'pickaxe', minTool: 'iron', drops: ITEM.DIAMOND },
        [BLOCK.GOLD_ORE]: { name: 'Gold Ore',    hardness: 4.5,  top: 0xfcee4b, side: 0xfcee4b, bottom: 0xfcee4b, solid: true, toolType: 'pickaxe', minTool: 'iron' },
        [BLOCK.CRAFTING_TABLE]: { name: 'Crafting Table', hardness: 2.5, top: 0xbc9862, side: 0x9c7f4a, bottom: 0xb8945f, solid: true, toolType: 'axe' }
      };

      // Item data
      const ITEM_DATA = {
        [ITEM.COAL]:       { name: 'Coal',       color: 0x333333, stackable: true },
        [ITEM.IRON_INGOT]: { name: 'Iron Ingot', color: 0xd8d8d8, stackable: true },
        [ITEM.GOLD_INGOT]: { name: 'Gold Ingot', color: 0xfcee4b, stackable: true },
        [ITEM.DIAMOND]:    { name: 'Diamond',    color: 0x4aedd9, stackable: true },
        [ITEM.STICK]:      { name: 'Stick',      color: 0x8b6914, stackable: true },
        
        [ITEM.WOODEN_PICKAXE]:  { name: 'Wooden Pickaxe',  color: 0x8b6914, durability: 60,  miningSpeed: 2, toolType: 'pickaxe', toolTier: 'wooden', isTool: true },
        [ITEM.STONE_PICKAXE]:   { name: 'Stone Pickaxe',   color: 0x7f7f7f, durability: 132, miningSpeed: 4, toolType: 'pickaxe', toolTier: 'stone', isTool: true },
        [ITEM.IRON_PICKAXE]:    { name: 'Iron Pickaxe',    color: 0xd8d8d8, durability: 251, miningSpeed: 6, toolType: 'pickaxe', toolTier: 'iron', isTool: true },
        [ITEM.DIAMOND_PICKAXE]: { name: 'Diamond Pickaxe', color: 0x4aedd9, durability: 1562, miningSpeed: 8, toolType: 'pickaxe', toolTier: 'diamond', isTool: true },
        [ITEM.GOLD_PICKAXE]:    { name: 'Gold Pickaxe',    color: 0xfcee4b, durability: 33,  miningSpeed: 12, toolType: 'pickaxe', toolTier: 'gold', isTool: true },
        
        [ITEM.WOODEN_AXE]:  { name: 'Wooden Axe',  color: 0x8b6914, durability: 60,  miningSpeed: 2, toolType: 'axe', toolTier: 'wooden', isTool: true },
        [ITEM.STONE_AXE]:   { name: 'Stone Axe',   color: 0x7f7f7f, durability: 132, miningSpeed: 4, toolType: 'axe', toolTier: 'stone', isTool: true },
        [ITEM.IRON_AXE]:    { name: 'Iron Axe',    color: 0xd8d8d8, durability: 251, miningSpeed: 6, toolType: 'axe', toolTier: 'iron', isTool: true },
        [ITEM.DIAMOND_AXE]: { name: 'Diamond Axe', color: 0x4aedd9, durability: 1562, miningSpeed: 8, toolType: 'axe', toolTier: 'diamond', isTool: true },
        
        [ITEM.WOODEN_SHOVEL]:  { name: 'Wooden Shovel',  color: 0x8b6914, durability: 60,  miningSpeed: 2, toolType: 'shovel', toolTier: 'wooden', isTool: true },
        [ITEM.STONE_SHOVEL]:   { name: 'Stone Shovel',   color: 0x7f7f7f, durability: 132, miningSpeed: 4, toolType: 'shovel', toolTier: 'stone', isTool: true },
        [ITEM.IRON_SHOVEL]:    { name: 'Iron Shovel',    color: 0xd8d8d8, durability: 251, miningSpeed: 6, toolType: 'shovel', toolTier: 'iron', isTool: true },
        [ITEM.DIAMOND_SHOVEL]: { name: 'Diamond Shovel', color: 0x4aedd9, durability: 1562, miningSpeed: 8, toolType: 'shovel', toolTier: 'diamond', isTool: true },
        
        [ITEM.WOODEN_SWORD]: { name: 'Wooden Sword', color: 0x8b6914, durability: 60,  damage: 4, isTool: true },
        [ITEM.STONE_SWORD]:  { name: 'Stone Sword',  color: 0x7f7f7f, durability: 132, damage: 5, isTool: true },
        [ITEM.IRON_SWORD]:   { name: 'Iron Sword',   color: 0xd8d8d8, durability: 251, damage: 6, isTool: true },
        [ITEM.DIAMOND_SWORD]:{ name: 'Diamond Sword',color: 0x4aedd9, durability: 1562, damage: 7, isTool: true }
      };

      // Tool tier hierarchy for mining requirements
      const TOOL_TIERS = ['wooden', 'stone', 'iron', 'diamond', 'gold'];

      // Crafting recipes
      const RECIPES = [
        // Basic items
        { result: BLOCK.PLANKS, resultCount: 4, ingredients: [{ item: BLOCK.WOOD, count: 1 }], name: 'Oak Planks' },
        { result: ITEM.STICK, resultCount: 4, ingredients: [{ item: BLOCK.PLANKS, count: 2 }], name: 'Sticks' },
        { result: BLOCK.CRAFTING_TABLE, resultCount: 1, ingredients: [{ item: BLOCK.PLANKS, count: 4 }], name: 'Crafting Table' },
        
        // Wooden tools
        { result: ITEM.WOODEN_PICKAXE, resultCount: 1, ingredients: [{ item: BLOCK.PLANKS, count: 3 }, { item: ITEM.STICK, count: 2 }], name: 'Wooden Pickaxe' },
        { result: ITEM.WOODEN_AXE, resultCount: 1, ingredients: [{ item: BLOCK.PLANKS, count: 3 }, { item: ITEM.STICK, count: 2 }], name: 'Wooden Axe' },
        { result: ITEM.WOODEN_SHOVEL, resultCount: 1, ingredients: [{ item: BLOCK.PLANKS, count: 1 }, { item: ITEM.STICK, count: 2 }], name: 'Wooden Shovel' },
        { result: ITEM.WOODEN_SWORD, resultCount: 1, ingredients: [{ item: BLOCK.PLANKS, count: 2 }, { item: ITEM.STICK, count: 1 }], name: 'Wooden Sword' },
        
        // Stone tools
        { result: ITEM.STONE_PICKAXE, resultCount: 1, ingredients: [{ item: BLOCK.COBBLE, count: 3 }, { item: ITEM.STICK, count: 2 }], name: 'Stone Pickaxe' },
        { result: ITEM.STONE_AXE, resultCount: 1, ingredients: [{ item: BLOCK.COBBLE, count: 3 }, { item: ITEM.STICK, count: 2 }], name: 'Stone Axe' },
        { result: ITEM.STONE_SHOVEL, resultCount: 1, ingredients: [{ item: BLOCK.COBBLE, count: 1 }, { item: ITEM.STICK, count: 2 }], name: 'Stone Shovel' },
        { result: ITEM.STONE_SWORD, resultCount: 1, ingredients: [{ item: BLOCK.COBBLE, count: 2 }, { item: ITEM.STICK, count: 1 }], name: 'Stone Sword' },
        
        // Iron tools
        { result: ITEM.IRON_PICKAXE, resultCount: 1, ingredients: [{ item: ITEM.IRON_INGOT, count: 3 }, { item: ITEM.STICK, count: 2 }], name: 'Iron Pickaxe' },
        { result: ITEM.IRON_AXE, resultCount: 1, ingredients: [{ item: ITEM.IRON_INGOT, count: 3 }, { item: ITEM.STICK, count: 2 }], name: 'Iron Axe' },
        { result: ITEM.IRON_SHOVEL, resultCount: 1, ingredients: [{ item: ITEM.IRON_INGOT, count: 1 }, { item: ITEM.STICK, count: 2 }], name: 'Iron Shovel' },
        { result: ITEM.IRON_SWORD, resultCount: 1, ingredients: [{ item: ITEM.IRON_INGOT, count: 2 }, { item: ITEM.STICK, count: 1 }], name: 'Iron Sword' },
        
        // Diamond tools
        { result: ITEM.DIAMOND_PICKAXE, resultCount: 1, ingredients: [{ item: ITEM.DIAMOND, count: 3 }, { item: ITEM.STICK, count: 2 }], name: 'Diamond Pickaxe' },
        { result: ITEM.DIAMOND_AXE, resultCount: 1, ingredients: [{ item: ITEM.DIAMOND, count: 3 }, { item: ITEM.STICK, count: 2 }], name: 'Diamond Axe' },
        { result: ITEM.DIAMOND_SHOVEL, resultCount: 1, ingredients: [{ item: ITEM.DIAMOND, count: 1 }, { item: ITEM.STICK, count: 2 }], name: 'Diamond Shovel' },
        { result: ITEM.DIAMOND_SWORD, resultCount: 1, ingredients: [{ item: ITEM.DIAMOND, count: 2 }, { item: ITEM.STICK, count: 1 }], name: 'Diamond Sword' },
        
        // Smelting (simplified)
        { result: ITEM.IRON_INGOT, resultCount: 1, ingredients: [{ item: BLOCK.IRON_ORE, count: 1 }, { item: ITEM.COAL, count: 1 }], name: 'Smelt Iron' },
        { result: ITEM.GOLD_INGOT, resultCount: 1, ingredients: [{ item: BLOCK.GOLD_ORE, count: 1 }, { item: ITEM.COAL, count: 1 }], name: 'Smelt Gold' },
        { result: BLOCK.GLASS, resultCount: 1, ingredients: [{ item: BLOCK.SAND, count: 1 }, { item: ITEM.COAL, count: 1 }], name: 'Smelt Glass' },
        { result: BLOCK.STONE, resultCount: 1, ingredients: [{ item: BLOCK.COBBLE, count: 1 }, { item: ITEM.COAL, count: 1 }], name: 'Smelt Stone' }
      ];
      
      const FACE_DATA = {
        top:    { dir: [0,1,0],  shade: 1.0, corners: [{pos:[0,1,0],neighbors:[[-1,1,0],[0,1,-1],[-1,1,-1]]},{pos:[0,1,1],neighbors:[[-1,1,0],[0,1,1],[-1,1,1]]},{pos:[1,1,1],neighbors:[[1,1,0],[0,1,1],[1,1,1]]},{pos:[1,1,0],neighbors:[[1,1,0],[0,1,-1],[1,1,-1]]}]},
        bottom: { dir: [0,-1,0], shade: 0.5, corners: [{pos:[0,0,1],neighbors:[[-1,-1,0],[0,-1,1],[-1,-1,1]]},{pos:[0,0,0],neighbors:[[-1,-1,0],[0,-1,-1],[-1,-1,-1]]},{pos:[1,0,0],neighbors:[[1,-1,0],[0,-1,-1],[1,-1,-1]]},{pos:[1,0,1],neighbors:[[1,-1,0],[0,-1,1],[1,-1,1]]}]},
        front:  { dir: [0,0,1],  shade: 0.7, corners: [{pos:[0,0,1],neighbors:[[-1,0,1],[0,-1,1],[-1,-1,1]]},{pos:[1,0,1],neighbors:[[1,0,1],[0,-1,1],[1,-1,1]]},{pos:[1,1,1],neighbors:[[1,0,1],[0,1,1],[1,1,1]]},{pos:[0,1,1],neighbors:[[-1,0,1],[0,1,1],[-1,1,1]]}]},
        back:   { dir: [0,0,-1], shade: 0.7, corners: [{pos:[1,0,0],neighbors:[[1,0,-1],[0,-1,-1],[1,-1,-1]]},{pos:[0,0,0],neighbors:[[-1,0,-1],[0,-1,-1],[-1,-1,-1]]},{pos:[0,1,0],neighbors:[[-1,0,-1],[0,1,-1],[-1,1,-1]]},{pos:[1,1,0],neighbors:[[1,0,-1],[0,1,-1],[1,1,-1]]}]},
        right:  { dir: [1,0,0],  shade: 0.85,corners: [{pos:[1,0,0],neighbors:[[1,0,-1],[1,-1,0],[1,-1,-1]]},{pos:[1,1,0],neighbors:[[1,0,-1],[1,1,0],[1,1,-1]]},{pos:[1,1,1],neighbors:[[1,0,1],[1,1,0],[1,1,1]]},{pos:[1,0,1],neighbors:[[1,0,1],[1,-1,0],[1,-1,1]]}]},
        left:   { dir: [-1,0,0], shade: 0.65,corners: [{pos:[0,0,1],neighbors:[[-1,0,1],[-1,-1,0],[-1,-1,1]]},{pos:[0,1,1],neighbors:[[-1,0,1],[-1,1,0],[-1,1,1]]},{pos:[0,1,0],neighbors:[[-1,0,-1],[-1,1,0],[-1,1,-1]]},{pos:[0,0,0],neighbors:[[-1,0,-1],[-1,-1,0],[-1,-1,-1]]}]}
      };

      // ==================== SIMPLEX NOISE ====================
      class SimplexNoise {
        constructor(seed = Math.random() * 10000) {
          this.p = new Uint8Array(256);
          for (let i = 0; i < 256; i++) this.p[i] = i;
          let n = seed;
          for (let i = 255; i > 0; i--) {
            n = ((n * 16807) % 2147483647);
            const j = n % (i + 1);
            [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
          }
          this.perm = new Uint8Array(512);
          this.permMod12 = new Uint8Array(512);
          for (let i = 0; i < 512; i++) {
            this.perm[i] = this.p[i & 255];
            this.permMod12[i] = this.perm[i] % 12;
          }
        }

        noise2D(x, y) {
          const F2 = 0.5 * (Math.sqrt(3) - 1);
          const G2 = (3 - Math.sqrt(3)) / 6;
          const grad3 = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];

          let s = (x + y) * F2;
          let i = Math.floor(x + s);
          let j = Math.floor(y + s);
          let t = (i + j) * G2;
          let X0 = i - t, Y0 = j - t;
          let x0 = x - X0, y0 = y - Y0;
          let i1, j1;
          if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }
          let x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
          let x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;
          let ii = i & 255, jj = j & 255;

          let n0 = 0, n1 = 0, n2 = 0;
          let t0 = 0.5 - x0*x0 - y0*y0;
          if (t0 >= 0) {
            let gi0 = this.permMod12[ii + this.perm[jj]];
            t0 *= t0; n0 = t0 * t0 * (grad3[gi0][0] * x0 + grad3[gi0][1] * y0);
          }
          let t1 = 0.5 - x1*x1 - y1*y1;
          if (t1 >= 0) {
            let gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]];
            t1 *= t1; n1 = t1 * t1 * (grad3[gi1][0] * x1 + grad3[gi1][1] * y1);
          }
          let t2 = 0.5 - x2*x2 - y2*y2;
          if (t2 >= 0) {
            let gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]];
            t2 *= t2; n2 = t2 * t2 * (grad3[gi2][0] * x2 + grad3[gi2][1] * y2);
          }
          return 70 * (n0 + n1 + n2);
        }

        octave(x, y, octaves, persistence = 0.5, lacunarity = 2) {
          let total = 0, frequency = 1, amplitude = 1, maxValue = 0;
          for (let i = 0; i < octaves; i++) {
            total += this.noise2D(x * frequency, y * frequency) * amplitude;
            maxValue += amplitude;
            amplitude *= persistence;
            frequency *= lacunarity;
          }
          return total / maxValue;
        }
      }

      // ==================== GAME CLASS ====================
      class MinecraftGame {
        constructor() {
          // Settings
          this.settings = {
            renderDistance: 2,
            shadowsEnabled: false,
            shadowDistance: 200,
            fov: 80,
            sensitivity: 1.0,
            fullscreen: false
          };
          
          this.scene = new THREE.Scene();
          this.camera = new THREE.PerspectiveCamera(this.settings.fov, window.innerWidth / window.innerHeight, 0.01, 500);
          this.renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          this.renderer.setClearColor(0x87ceeb);
          document.getElementById('game-container').prepend(this.renderer.domElement);

          this.noise = new SimplexNoise(42);
          this.noiseDetail = new SimplexNoise(123);
          this.chunks = new Map();
          this.chunkMeshes = new Map();
          this.modifiedBlocks = new Map();
          this.pendingChunks = new Set();

          this.player = {
            position: new THREE.Vector3(8, 50, 8),
            velocity: new THREE.Vector3(),
            onGround: false,
            yaw: 0,
            pitch: 0,
            inWater: false,
            health: MAX_HEALTH,
            fallStartY: null,
            isDead: false
          };

          this.keys = {};
          this.selectedSlot = 0;
          
          // Inventory system: each slot has { id, count, durability? }
          this.hotbarSlots = new Array(9).fill(null);
          this.inventorySlots = new Array(27).fill(null);
          this.inventoryOpen = false;

          this.isPlaying = false;
          this.isPaused = false;
          this.lastTime = 0;
          this.frameCount = 0;
          this.fpsTime = 0;
          this.fps = 0;

          this.targetBlock = null;
          this.placementBlock = null;
          this.breakProgress = 0;
          this.breaking = false;
          this.currentBreakingBlock = null;
          
          this.placing = false;
          this.placeCooldown = 0;

          this.particleSystem = [];
          
          this.gameMode = 'survival';
          this.isFlying = false;
          this.lastSpacePress = 0;

          this.init();
        }

        init() {
          this.setupLighting();
          this.setupHighlight();
          this.setupHotbar();
          this.setupHealthBar();
          this.setupEventListeners();
          this.setupSettingsUI();
          this.setupInventoryUI();
        }

        setupLighting() {
          const ambient = new THREE.AmbientLight(0xffffff, 0.7);
          this.scene.add(ambient);
        
          this.sun = new THREE.DirectionalLight(0xfff5e0, 1.2);
          this.sun.position.set(100, 200, 50);
          
          this.sunTarget = new THREE.Object3D();
          this.scene.add(this.sunTarget);
          this.sun.target = this.sunTarget;
          this.scene.add(this.sun);
        
          this.updateFog();
        }

        updateShadows() {
          if (this.settings.shadowsEnabled) {
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.VSMShadowMap;
            this.sun.castShadow = true;
            
            const res = this.settings.shadowDistance;
            this.sun.shadow.mapSize.set(res * 8, res * 8);
            
            const d = this.settings.shadowDistance / 2;
            this.sun.shadow.camera.left = -d;
            this.sun.shadow.camera.right = d;
            this.sun.shadow.camera.top = d;
            this.sun.shadow.camera.bottom = -d;
            this.sun.shadow.camera.near = 1;
            this.sun.shadow.camera.far = 350;
            this.sun.shadow.blurSamples = 4;
            this.sun.shadow.bias = -0.0002;
            this.sun.shadow.normalBias = 0;
            this.sun.shadow.camera.updateProjectionMatrix();
            
            // Update existing meshes
            this.chunkMeshes.forEach((group) => {
              group.children.forEach(mesh => {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
              });
            });
          } else {
            this.renderer.shadowMap.enabled = false;
            this.sun.castShadow = false;
            
            this.chunkMeshes.forEach((group) => {
              group.children.forEach(mesh => {
                mesh.castShadow = false;
                mesh.receiveShadow = false;
              });
            });
          }
        }

        updateFog() {
          const viewDistance = CHUNK_SIZE * this.settings.renderDistance;
          this.scene.fog = new THREE.Fog(0x87ceeb, viewDistance * 0.5, viewDistance * 0.9);
        }

        setupHighlight() {
          const geo = new THREE.BoxGeometry(1.005, 1.005, 1.005);
          const edges = new THREE.EdgesGeometry(geo);
          this.highlight = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
          this.highlight.visible = false;
          this.scene.add(this.highlight);
        }

        setupHealthBar() {
          const container = document.getElementById('health-bar');
          container.innerHTML = '';
          
          for (let i = 0; i < 10; i++) {
            const heart = document.createElement('div');
            heart.className = 'heart';
            const fill = document.createElement('div');
            fill.className = 'heart-fill';
            fill.id = `heart-${i}`;
            heart.appendChild(fill);
            container.appendChild(heart);
          }
          
          this.updateHealthBar();
        }

        updateHealthBar() {
          const health = this.player.health;
          for (let i = 0; i < 10; i++) {
            const fill = document.getElementById(`heart-${i}`);
            const heartValue = (i + 1) * 2;
            
            if (health >= heartValue) {
              fill.className = 'heart-fill';
            } else if (health >= heartValue - 1) {
              fill.className = 'heart-fill half';
            } else {
              fill.className = 'heart-fill empty';
            }
          }
          
          // Hide health bar in creative mode
          document.getElementById('health-bar').style.display = 
            this.gameMode === 'creative' ? 'none' : 'flex';
        }

        setupSettingsUI() {
          const panel = document.getElementById('settings-panel');
          
          // Render distance
          const rdSlider = document.getElementById('setting-render-distance');
          rdSlider.value = this.settings.renderDistance;
          document.getElementById('render-distance-value').textContent = this.settings.renderDistance;
          rdSlider.oninput = () => {
            this.settings.renderDistance = parseInt(rdSlider.value);
            document.getElementById('render-distance-value').textContent = this.settings.renderDistance;
          };
          
          // Shadows
          const shadowCheck = document.getElementById('setting-shadows');
          shadowCheck.checked = this.settings.shadowsEnabled;
          document.getElementById('shadow-distance-row').style.display = 
            this.settings.shadowsEnabled ? 'flex' : 'none';
          shadowCheck.onchange = () => {
            this.settings.shadowsEnabled = shadowCheck.checked;
            document.getElementById('shadow-distance-row').style.display = 
              shadowCheck.checked ? 'flex' : 'none';
            if (this.isPlaying) this.updateShadows();
          };
          
          // Shadow distance
          const sdSlider = document.getElementById('setting-shadow-distance');
          sdSlider.value = this.settings.shadowDistance;
          document.getElementById('shadow-distance-value').textContent = this.settings.shadowDistance;
          sdSlider.oninput = () => {
            this.settings.shadowDistance = parseInt(sdSlider.value);
            document.getElementById('shadow-distance-value').textContent = this.settings.shadowDistance;
            if (this.isPlaying && this.settings.shadowsEnabled) this.updateShadows();
          };
          
          // FOV
          const fovSlider = document.getElementById('setting-fov');
          fovSlider.value = this.settings.fov;
          document.getElementById('fov-value').textContent = this.settings.fov;
          fovSlider.oninput = () => {
            this.settings.fov = parseInt(fovSlider.value);
            document.getElementById('fov-value').textContent = this.settings.fov;
            this.camera.fov = this.settings.fov;
            this.camera.updateProjectionMatrix();
          };
          
          // Sensitivity
          const sensSlider = document.getElementById('setting-sensitivity');
          sensSlider.value = this.settings.sensitivity;
          document.getElementById('sensitivity-value').textContent = this.settings.sensitivity.toFixed(1);
          sensSlider.oninput = () => {
            this.settings.sensitivity = parseFloat(sensSlider.value);
            document.getElementById('sensitivity-value').textContent = this.settings.sensitivity.toFixed(1);
          };
          
          // Fullscreen
          const fsCheck = document.getElementById('setting-fullscreen');
          fsCheck.checked = this.settings.fullscreen;
          fsCheck.onchange = () => {
            this.settings.fullscreen = fsCheck.checked;
            if (fsCheck.checked) {
              document.documentElement.requestFullscreen?.();
            } else {
              document.exitFullscreen?.();
            }
          };
          
          // Settings buttons
          document.getElementById('settings-btn').onclick = () => {
            panel.classList.add('visible');
          };
          
          document.getElementById('settings-close-btn').onclick = () => {
            panel.classList.remove('visible');
            this.updateFog();
          };
        }

        setupInventoryUI() {
          this.updateInventoryUI();
        }

        updateInventoryUI() {
          const mainInv = document.getElementById('main-inventory');
          const hotbarInv = document.getElementById('hotbar-inventory');
          const recipeList = document.getElementById('recipe-list');
          
          mainInv.innerHTML = '';
          hotbarInv.innerHTML = '';
          recipeList.innerHTML = '';
          
          // Main inventory slots
          for (let i = 0; i < 27; i++) {
            const slot = this.createInventorySlot(this.inventorySlots[i], 'inventory', i);
            mainInv.appendChild(slot);
          }
          
          // Hotbar slots in inventory
          for (let i = 0; i < 9; i++) {
            const slot = this.createInventorySlot(this.hotbarSlots[i], 'hotbar', i);
            hotbarInv.appendChild(slot);
          }
          
          // Recipes
          const recipes = this.gameMode === 'creative' ? this.getCreativeItems() : RECIPES;
          
          if (this.gameMode === 'creative') {
            // Show all blocks and items for creative mode
            recipes.forEach(item => {
              const recipeEl = document.createElement('div');
              recipeEl.className = 'recipe-item can-craft';
              recipeEl.innerHTML = `
                <span class="recipe-result">${item.name}</span>
              `;
              recipeEl.onclick = () => this.giveItem(item.id, 64);
              recipeList.appendChild(recipeEl);
            });
          } else {
            // Show actual recipes for survival
            RECIPES.forEach(recipe => {
              const canCraft = this.canCraftRecipe(recipe);
              const recipeEl = document.createElement('div');
              recipeEl.className = 'recipe-item' + (canCraft ? ' can-craft' : '');
              
              const ingredientStr = recipe.ingredients.map(ing => {
                const name = this.getItemName(ing.item);
                const has = this.countItem(ing.item);
                return `${has}/${ing.count} ${name}`;
              }).join(' + ');
              
              recipeEl.innerHTML = `
                <span class="recipe-ingredients">${ingredientStr}</span>
                <span class="recipe-arrow">→</span>
                <span class="recipe-result">${recipe.resultCount}x ${recipe.name}</span>
              `;
              
              if (canCraft) {
                recipeEl.onclick = () => this.craftRecipe(recipe);
              }
              
              recipeList.appendChild(recipeEl);
            });
          }
        }

        getCreativeItems() {
          const items = [];
          
          // Add all blocks
          for (const [id, data] of Object.entries(BLOCK_DATA)) {
            items.push({ id: parseInt(id), name: data.name });
          }
          
          // Add all items
          for (const [id, data] of Object.entries(ITEM_DATA)) {
            items.push({ id: parseInt(id), name: data.name });
          }
          
          return items;
        }

        createInventorySlot(slotData, type, index) {
          const slot = document.createElement('div');
          slot.className = 'inv-slot';
          
          if (slotData) {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            this.drawItemIcon(canvas, slotData.id);
            slot.appendChild(canvas);
            
            if (slotData.count > 1) {
              const count = document.createElement('span');
              count.className = 'slot-count';
              count.textContent = slotData.count;
              slot.appendChild(count);
            }
            
            // Durability bar for tools
            const itemData = ITEM_DATA[slotData.id];
            if (itemData?.durability && slotData.durability !== undefined) {
              const durBar = document.createElement('div');
              durBar.className = 'durability-bar';
              const durFill = document.createElement('div');
              durFill.className = 'durability-fill';
              durFill.style.width = (slotData.durability / itemData.durability * 100) + '%';
              durFill.style.background = this.getDurabilityColor(slotData.durability / itemData.durability);
              durBar.appendChild(durFill);
              slot.appendChild(durBar);
            }
          }
          
          slot.onclick = () => this.handleInventoryClick(type, index);
          
          return slot;
        }

        getDurabilityColor(ratio) {
          if (ratio > 0.6) return '#4ade80';
          if (ratio > 0.3) return '#fbbf24';
          return '#ef4444';
        }

        handleInventoryClick(type, index) {
          if (this.gameMode === 'creative') return;
          
          // Simple swap logic
          const slots = type === 'hotbar' ? this.hotbarSlots : this.inventorySlots;
          const item = slots[index];
          
          // For now, just log - could implement drag/drop
          console.log('Clicked', type, index, item);
        }

        setupHotbar() {
          this.updateHotbar();
        }

        drawItemIcon(canvas, itemId) {
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, 32, 32);
          
          // Check if it's a block or item
          if (BLOCK_DATA[itemId]) {
            this.drawBlockIcon(canvas, itemId);
          } else if (ITEM_DATA[itemId]) {
            this.drawToolIcon(canvas, itemId);
          }
        }

        drawBlockIcon(canvas, type) {
          const ctx = canvas.getContext('2d');
          const data = BLOCK_DATA[type];
          if (!data) return;

          const toRGB = hex => `rgb(${(hex>>16)&255},${(hex>>8)&255},${hex&255})`;
          const darken = (hex, f) => {
            let r = ((hex>>16)&255)*f, g = ((hex>>8)&255)*f, b = (hex&255)*f;
            return `rgb(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)})`;
          };

          ctx.fillStyle = toRGB(data.top);
          ctx.beginPath();
          ctx.moveTo(16, 4); ctx.lineTo(28, 10); ctx.lineTo(16, 16); ctx.lineTo(4, 10);
          ctx.closePath(); ctx.fill();

          ctx.fillStyle = darken(data.side, 0.6);
          ctx.beginPath();
          ctx.moveTo(4, 10); ctx.lineTo(16, 16); ctx.lineTo(16, 28); ctx.lineTo(4, 22);
          ctx.closePath(); ctx.fill();

          ctx.fillStyle = darken(data.side, 0.8);
          ctx.beginPath();
          ctx.moveTo(28, 10); ctx.lineTo(16, 16); ctx.lineTo(16, 28); ctx.lineTo(28, 22);
          ctx.closePath(); ctx.fill();
        }

        drawToolIcon(canvas, itemId) {
          const ctx = canvas.getContext('2d');
          const data = ITEM_DATA[itemId];
          if (!data) return;
          
          const toRGB = hex => `rgb(${(hex>>16)&255},${(hex>>8)&255},${hex&255})`;
          
          ctx.fillStyle = toRGB(data.color);
          
          if (data.toolType === 'pickaxe') {
            // Pickaxe shape
            ctx.fillRect(14, 2, 4, 4);
            ctx.fillRect(10, 6, 12, 4);
            ctx.fillRect(14, 10, 4, 18);
          } else if (data.toolType === 'axe') {
            // Axe shape
            ctx.fillRect(18, 2, 8, 8);
            ctx.fillRect(14, 6, 4, 4);
            ctx.fillRect(14, 10, 4, 18);
          } else if (data.toolType === 'shovel') {
            // Shovel shape
            ctx.fillRect(12, 2, 8, 10);
            ctx.fillRect(14, 12, 4, 16);
          } else if (data.name?.includes('Sword')) {
            // Sword shape
            ctx.fillRect(14, 2, 4, 20);
            ctx.fillRect(10, 22, 12, 4);
            ctx.fillRect(14, 26, 4, 4);
          } else {
            // Generic item (diamond, coal, etc)
            ctx.beginPath();
            ctx.arc(16, 16, 10, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        updateHotbar() {
          const container = document.getElementById('hotbar');
          container.innerHTML = '';

          for (let i = 0; i < 9; i++) {
            const slotData = this.hotbarSlots[i];
            const slot = document.createElement('div');
            slot.className = 'hotbar-slot' + (i === this.selectedSlot ? ' selected' : '');

            if (slotData) {
              const canvas = document.createElement('canvas');
              canvas.width = 32;
              canvas.height = 32;
              this.drawItemIcon(canvas, slotData.id);
              slot.appendChild(canvas);
              
              if (slotData.count > 1) {
                const count = document.createElement('span');
                count.className = 'slot-count';
                count.textContent = slotData.count;
                slot.appendChild(count);
              }

              const name = document.createElement('span');
              name.className = 'slot-name';
              name.textContent = this.getItemName(slotData.id);
              slot.appendChild(name);
              
              // Durability bar
              const itemData = ITEM_DATA[slotData.id];
              if (itemData?.durability && slotData.durability !== undefined) {
                const durBar = document.createElement('div');
                durBar.className = 'durability-bar';
                const durFill = document.createElement('div');
                durFill.className = 'durability-fill';
                durFill.style.width = (slotData.durability / itemData.durability * 100) + '%';
                durFill.style.background = this.getDurabilityColor(slotData.durability / itemData.durability);
                durBar.appendChild(durFill);
                slot.appendChild(durBar);
              }
            }

            const num = document.createElement('span');
            num.className = 'slot-number';
            num.textContent = i + 1;
            slot.appendChild(num);

            slot.onclick = () => { this.selectedSlot = i; this.updateHotbar(); };
            container.appendChild(slot);
          }
        }

        getItemName(itemId) {
          if (BLOCK_DATA[itemId]) return BLOCK_DATA[itemId].name;
          if (ITEM_DATA[itemId]) return ITEM_DATA[itemId].name;
          return 'Unknown';
        }

        getHeldItem() {
          return this.hotbarSlots[this.selectedSlot];
        }

        getHeldTool() {
          const held = this.getHeldItem();
          if (!held) return null;
          const data = ITEM_DATA[held.id];
          if (data?.isTool) return { ...data, durability: held.durability, slotIndex: this.selectedSlot };
          return null;
        }

        // Inventory management
        addToInventory(itemId, count = 1, durability = undefined) {
          // Check if item is stackable
          const itemData = ITEM_DATA[itemId];
          const blockData = BLOCK_DATA[itemId];
          const isStackable = itemData?.stackable !== false && !itemData?.isTool;
          
          let remaining = count;
          
          if (isStackable) {
            // Try to stack in hotbar first
            for (let i = 0; i < this.hotbarSlots.length && remaining > 0; i++) {
              const slot = this.hotbarSlots[i];
              if (slot && slot.id === itemId && slot.count < MAX_STACK_SIZE) {
                const add = Math.min(remaining, MAX_STACK_SIZE - slot.count);
                slot.count += add;
                remaining -= add;
              }
            }
            
            // Then inventory
            for (let i = 0; i < this.inventorySlots.length && remaining > 0; i++) {
              const slot = this.inventorySlots[i];
              if (slot && slot.id === itemId && slot.count < MAX_STACK_SIZE) {
                const add = Math.min(remaining, MAX_STACK_SIZE - slot.count);
                slot.count += add;
                remaining -= add;
              }
            }
          }
          
          // Find empty slots for remaining items
          while (remaining > 0) {
            const addCount = isStackable ? Math.min(remaining, MAX_STACK_SIZE) : 1;
            let added = false;
            
            // Try hotbar first
            for (let i = 0; i < this.hotbarSlots.length; i++) {
              if (!this.hotbarSlots[i]) {
                this.hotbarSlots[i] = { 
                  id: itemId, 
                  count: addCount,
                  durability: durability !== undefined ? durability : (ITEM_DATA[itemId]?.durability)
                };
                remaining -= addCount;
                added = true;
                break;
              }
            }
            
            // Then inventory
            if (!added) {
              for (let i = 0; i < this.inventorySlots.length; i++) {
                if (!this.inventorySlots[i]) {
                  this.inventorySlots[i] = { 
                    id: itemId, 
                    count: addCount,
                    durability: durability !== undefined ? durability : (ITEM_DATA[itemId]?.durability)
                  };
                  remaining -= addCount;
                  added = true;
                  break;
                }
              }
            }
            
            if (!added) break; // Inventory full
          }
          
          this.updateHotbar();
          if (this.inventoryOpen) this.updateInventoryUI();
          
          return remaining === 0;
        }

        removeFromInventory(itemId, count = 1) {
          let remaining = count;
          
          // Remove from hotbar first
          for (let i = 0; i < this.hotbarSlots.length && remaining > 0; i++) {
            const slot = this.hotbarSlots[i];
            if (slot && slot.id === itemId) {
              const remove = Math.min(remaining, slot.count);
              slot.count -= remove;
              remaining -= remove;
              if (slot.count <= 0) this.hotbarSlots[i] = null;
            }
          }
          
          // Then from inventory
          for (let i = 0; i < this.inventorySlots.length && remaining > 0; i++) {
            const slot = this.inventorySlots[i];
            if (slot && slot.id === itemId) {
              const remove = Math.min(remaining, slot.count);
              slot.count -= remove;
              remaining -= remove;
              if (slot.count <= 0) this.inventorySlots[i] = null;
            }
          }
          
          this.updateHotbar();
          if (this.inventoryOpen) this.updateInventoryUI();
          
          return remaining === 0;
        }

        countItem(itemId) {
          let count = 0;
          
          for (const slot of this.hotbarSlots) {
            if (slot && slot.id === itemId) count += slot.count;
          }
          
          for (const slot of this.inventorySlots) {
            if (slot && slot.id === itemId) count += slot.count;
          }
          
          return count;
        }

        giveItem(itemId, count = 1) {
          const itemData = ITEM_DATA[itemId];
          this.addToInventory(itemId, count, itemData?.durability);
        }

        canCraftRecipe(recipe) {
          for (const ing of recipe.ingredients) {
            if (this.countItem(ing.item) < ing.count) return false;
          }
          return true;
        }

        craftRecipe(recipe) {
          if (!this.canCraftRecipe(recipe)) return false;
          
          // Remove ingredients
          for (const ing of recipe.ingredients) {
            this.removeFromInventory(ing.item, ing.count);
          }
          
          // Add result
          const resultData = ITEM_DATA[recipe.result];
          this.addToInventory(recipe.result, recipe.resultCount, resultData?.durability);
          
          this.updateInventoryUI();
          return true;
        }

        damageTool(slotIndex) {
          const slot = this.hotbarSlots[slotIndex];
          if (!slot) return;
          
          const itemData = ITEM_DATA[slot.id];
          if (!itemData?.isTool) return;
          
          slot.durability--;
          
          if (slot.durability <= 0) {
            this.hotbarSlots[slotIndex] = null;
          }
          
          this.updateHotbar();
        }

        updateGameModeIndicator() {
          const indicator = document.getElementById('gamemode-indicator');
          if (this.gameMode === 'creative') {
            indicator.textContent = 'Creative' + (this.isFlying ? ' (Flying)' : '');
            indicator.className = 'creative';
          } else {
            indicator.textContent = 'Survival';
            indicator.className = 'survival';
          }
          this.updateHealthBar();
          if (this.inventoryOpen) this.updateInventoryUI();
        }

        toggleGameMode() {
          this.gameMode = this.gameMode === 'survival' ? 'creative' : 'survival';
          if (this.gameMode === 'survival') {
            this.isFlying = false;
          }
          if (this.gameMode === 'creative') {
            this.player.health = MAX_HEALTH;
          }
          this.updateGameModeIndicator();
        }

        toggleInventory() {
          this.inventoryOpen = !this.inventoryOpen;
          const invScreen = document.getElementById('inventory-screen');
          
          if (this.inventoryOpen) {
            invScreen.classList.add('visible');
            document.exitPointerLock();
            this.updateInventoryUI();
          } else {
            invScreen.classList.remove('visible');
            if (this.isPlaying && !this.isPaused) {
              this.renderer.domElement.requestPointerLock();
            }
          }
        }

        setupEventListeners() {
          document.getElementById('start-btn').onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.startGame();
          };

          document.getElementById('respawn-btn').onclick = () => {
            this.respawn();
          };

          document.addEventListener('keydown', e => {
            if (this.keys[e.code]) return;
            this.keys[e.code] = true;
            
            if (e.code === 'KeyE' && this.isPlaying && !this.isPaused && !this.player.isDead) {
              this.toggleInventory();
              e.preventDefault();
              return;
            }
            
            if (this.inventoryOpen) return;
            
            if (e.code.startsWith('Digit') && e.code.length === 6) {
              const n = parseInt(e.code[5]) - 1;
              if (n >= 0 && n < 9) {
                this.selectedSlot = n;
                this.updateHotbar();
              }
            }
            
            if (e.code === 'KeyC' && this.isPlaying && !this.isPaused) {
              this.toggleGameMode();
            }
            
            if (e.code === 'Space' && this.gameMode === 'creative') {
              const now = performance.now();
              if (now - this.lastSpacePress < 300) {
                this.isFlying = !this.isFlying;
                this.player.velocity.y = 0;
                this.updateGameModeIndicator();
              }
              this.lastSpacePress = now;
            }
            
            if (e.code === 'Escape' && this.isPlaying && !this.inventoryOpen) {
              document.getElementById('settings-panel').classList.add('visible');
              document.exitPointerLock();
            }
            
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
              e.preventDefault();
            }
          });

          document.addEventListener('keyup', e => this.keys[e.code] = false);

          document.addEventListener('mousemove', e => {
            if (document.pointerLockElement && this.isPlaying && !this.isPaused && !this.inventoryOpen) {
              const sens = this.settings.sensitivity * 0.002;
              this.player.yaw -= e.movementX * sens;
              this.player.pitch = Math.max(-Math.PI/2 + 0.01, 
                                           Math.min(Math.PI/2 - 0.01, this.player.pitch - e.movementY * sens));
            }
          });

          document.addEventListener('mousedown', e => {
            if (!this.isPlaying || this.isPaused || this.inventoryOpen || this.player.isDead) return;
            if (!document.pointerLockElement) {
              this.renderer.domElement.requestPointerLock();
              return;
            }
            if (e.button === 0) this.breaking = true;
            else if (e.button === 2) {
              this.placing = true;
              this.placeBlock();
            }
          });

          document.addEventListener('mouseup', e => {
            if (e.button === 0) {
              this.breaking = false;
              this.breakProgress = 0;
              this.currentBreakingBlock = null;
              this.updateBreakIndicator(0);
            }
            if (e.button === 2) {
              this.placing = false;
            }
          });

          document.addEventListener('wheel', e => {
            if (!this.isPlaying || this.isPaused || this.inventoryOpen) return;
            this.selectedSlot = (this.selectedSlot + (e.deltaY > 0 ? 1 : -1) + 9) % 9;
            this.updateHotbar();
          });

          document.addEventListener('contextmenu', e => e.preventDefault());

          document.addEventListener('pointerlockchange', () => {
            if (!document.pointerLockElement && this.isPlaying && !this.isPaused && !this.inventoryOpen) {
              // Check if settings panel is open
              if (!document.getElementById('settings-panel').classList.contains('visible')) {
                this.isPaused = true;
                document.getElementById('menu').classList.remove('hidden');
                document.getElementById('menu').querySelector('h1').textContent = '⏸ PAUSED';
                document.getElementById('menu').querySelector('button').textContent = 'Resume';
              }
            }
          });

          window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
          });
        }

        updateBreakIndicator(progress) {
          const indicator = document.getElementById('break-indicator');
          const progressBar = document.getElementById('break-progress-bar');
          const progressFill = document.getElementById('break-progress-fill');
          
          if (progress > 0 && progress < 1) {
            indicator.classList.add('active');
            progressBar.classList.add('active');
            progressFill.style.width = (progress * 100) + '%';
            
            const inner = document.getElementById('break-indicator-inner');
            const crackSize = Math.floor(progress * 5) + 1;
            inner.style.background = `repeating-linear-gradient(
              ${45 + progress * 90}deg,
              transparent,
              transparent ${8 - crackSize}px,
              rgba(0,0,0,${0.3 + progress * 0.4}) ${8 - crackSize}px,
              rgba(0,0,0,${0.3 + progress * 0.4}) ${12 - crackSize}px
            )`;
          } else {
            indicator.classList.remove('active');
            progressBar.classList.remove('active');
          }
        }

        async startGame() {
          const menu = document.getElementById('menu');
          const menuTitle = menu.querySelector('h1');
          const menuButton = menu.querySelector('button');

          menu.classList.add('hidden');
          document.getElementById('settings-panel').classList.remove('visible');

          if (!this.isPlaying) {
            document.getElementById('loading').classList.add('show');
            await new Promise(r => setTimeout(r, 50));

            this.generateInitialChunks();
            this.findSpawnPoint();
            this.isPlaying = true;
            this.updateShadows();

            document.getElementById('loading').classList.remove('show');
            this.lastTime = performance.now();
            this.gameLoop();
          }

          this.isPaused = false;
          menuTitle.textContent = '⛏ MINECRAFT';
          menuButton.textContent = 'Play World';
          this.updateGameModeIndicator();

          await new Promise(r => setTimeout(r, 50));

          try {
            await this.renderer.domElement.requestPointerLock();
          } catch (err) {}
        }

        // ==================== WORLD GENERATION ====================

        getTerrainHeight(x, z) {
          const scale = 0.008;
          const detailScale = 0.03;

          let base = this.noise.octave(x * scale, z * scale, 4, 0.5);
          let detail = this.noiseDetail.octave(x * detailScale, z * detailScale, 2, 0.5);

          let height = 20 + base * 25 + detail * 5;

          let mountain = this.noise.octave(x * 0.004, z * 0.004, 3, 0.4);
          if (mountain > 0.3) {
            height += (mountain - 0.3) * 60;
          }

          return Math.floor(height);
        }

        getBiome(x, z) {
          const temp = this.noise.noise2D(x * 0.002, z * 0.002);
          const moisture = this.noiseDetail.noise2D(x * 0.003, z * 0.003);

          if (temp > 0.4) return 'desert';
          if (temp < -0.4) return 'snow';
          if (moisture > 0.3) return 'forest';
          return 'plains';
        }

        generateChunk(cx, cz) {
          const key = `${cx},${cz}`;
          if (this.chunks.has(key)) return;

          const chunk = new Uint8Array(CHUNK_SIZE * WORLD_HEIGHT * CHUNK_SIZE);

          for (let lx = 0; lx < CHUNK_SIZE; lx++) {
            for (let lz = 0; lz < CHUNK_SIZE; lz++) {
              const wx = cx * CHUNK_SIZE + lx;
              const wz = cz * CHUNK_SIZE + lz;
              const height = this.getTerrainHeight(wx, wz);
              const biome = this.getBiome(wx, wz);

              for (let y = 0; y < WORLD_HEIGHT; y++) {
                const idx = lx + y * CHUNK_SIZE + lz * CHUNK_SIZE * WORLD_HEIGHT;

                if (y === 0) {
                  chunk[idx] = BLOCK.BEDROCK;
                } else if (y < height - 4) {
                  const rand = Math.random();
                  if (rand < 0.008) chunk[idx] = BLOCK.COAL_ORE;
                  else if (rand < 0.012 && y < 40) chunk[idx] = BLOCK.IRON_ORE;
                  else if (rand < 0.014 && y < 20) chunk[idx] = BLOCK.GOLD_ORE;
                  else if (rand < 0.016 && y < 16) chunk[idx] = BLOCK.DIAMOND_ORE;
                  else chunk[idx] = BLOCK.STONE;
                } else if (y < height - 1) {
                  chunk[idx] = biome === 'desert' ? BLOCK.SAND : BLOCK.DIRT;
                } else if (y < height) {
                  if (biome === 'desert') chunk[idx] = BLOCK.SAND;
                  else if (biome === 'snow') chunk[idx] = BLOCK.SNOW;
                  else if (height <= WATER_LEVEL + 2) chunk[idx] = BLOCK.SAND;
                  else chunk[idx] = BLOCK.GRASS;
                } else if (y <= WATER_LEVEL) {
                  chunk[idx] = BLOCK.WATER;
                }
              }

              // Trees
              if (height > WATER_LEVEL + 2 && biome !== 'desert' && Math.random() < 0.015) {
                const treeHeight = 4 + Math.floor(Math.random() * 2);
                for (let ty = 0; ty < treeHeight; ty++) {
                  const y = height + ty;
                  if (y < WORLD_HEIGHT) {
                    chunk[lx + y * CHUNK_SIZE + lz * CHUNK_SIZE * WORLD_HEIGHT] = BLOCK.WOOD;
                  }
                }
                for (let dx = -2; dx <= 2; dx++) {
                  for (let dz = -2; dz <= 2; dz++) {
                    for (let dy = treeHeight - 1; dy <= treeHeight + 1; dy++) {
                      if (Math.abs(dx) === 2 && Math.abs(dz) === 2 && Math.random() < 0.5) continue;
                      const nx = lx + dx, nz = lz + dz, ny = height + dy;
                      if (nx >= 0 && nx < CHUNK_SIZE && nz >= 0 && nz < CHUNK_SIZE && ny < WORLD_HEIGHT) {
                        if (chunk[nx + ny * CHUNK_SIZE + nz * CHUNK_SIZE * WORLD_HEIGHT] === BLOCK.AIR) {
                          chunk[nx + ny * CHUNK_SIZE + nz * CHUNK_SIZE * WORLD_HEIGHT] = BLOCK.LEAVES;
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          this.chunks.set(key, chunk);
          this.applyModificationsToChunk(cx, cz);
          this.buildChunkMesh(cx, cz);
        }

        applyModificationsToChunk(cx, cz) {
          const chunk = this.chunks.get(`${cx},${cz}`);
          if (!chunk) return;
          
          for (let lx = 0; lx < CHUNK_SIZE; lx++) {
            for (let lz = 0; lz < CHUNK_SIZE; lz++) {
              for (let y = 0; y < WORLD_HEIGHT; y++) {
                const wx = cx * CHUNK_SIZE + lx;
                const wz = cz * CHUNK_SIZE + lz;
                const key = `${wx},${y},${wz}`;
                
                if (this.modifiedBlocks.has(key)) {
                  const idx = lx + y * CHUNK_SIZE + lz * CHUNK_SIZE * WORLD_HEIGHT;
                  chunk[idx] = this.modifiedBlocks.get(key);
                }
              }
            }
          }
        }

        generateInitialChunks() {
          const pcx = Math.floor(this.player.position.x / CHUNK_SIZE);
          const pcz = Math.floor(this.player.position.z / CHUNK_SIZE);

          const chunksToGenerate = [];
          for (let dx = -this.settings.renderDistance; dx <= this.settings.renderDistance; dx++) {
            for (let dz = -this.settings.renderDistance; dz <= this.settings.renderDistance; dz++) {
              if (dx*dx + dz*dz <= this.settings.renderDistance * this.settings.renderDistance) {
                chunksToGenerate.push({cx: pcx + dx, cz: pcz + dz, dist: dx*dx + dz*dz});
              }
            }
          }
          
          chunksToGenerate.sort((a, b) => a.dist - b.dist);
          
          for (const {cx, cz} of chunksToGenerate) {
            this.generateChunk(cx, cz);
          }
        }

        findSpawnPoint() {
          let x = 8, z = 8;
          let y = this.getTerrainHeight(x, z) + 2;
          while (y <= WATER_LEVEL + 1) {
            x += 16;
            y = this.getTerrainHeight(x, z) + 2;
          }
          this.player.position.set(x + 0.5, y, z + 0.5);
        }

        getBlock(x, y, z) {
          const key = `${x},${y},${z}`;
          if (this.modifiedBlocks.has(key)) return this.modifiedBlocks.get(key);

          if (y < 0 || y >= WORLD_HEIGHT) return BLOCK.AIR;

          const cx = Math.floor(x / CHUNK_SIZE);
          const cz = Math.floor(z / CHUNK_SIZE);
          const chunk = this.chunks.get(`${cx},${cz}`);

          if (!chunk) return BLOCK.AIR;

          const lx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
          const lz = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
          return chunk[lx + y * CHUNK_SIZE + lz * CHUNK_SIZE * WORLD_HEIGHT];
        }

        setBlock(x, y, z, type) {
          if (y < 0 || y >= WORLD_HEIGHT) return;

          this.modifiedBlocks.set(`${x},${y},${z}`, type);

          const cx = Math.floor(x / CHUNK_SIZE);
          const cz = Math.floor(z / CHUNK_SIZE);
          const chunk = this.chunks.get(`${cx},${cz}`);

          if (chunk) {
            const lx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
            const lz = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
            chunk[lx + y * CHUNK_SIZE + lz * CHUNK_SIZE * WORLD_HEIGHT] = type;

            this.buildChunkMesh(cx, cz);
            if (lx === 0) this.buildChunkMesh(cx - 1, cz);
            if (lx === CHUNK_SIZE - 1) this.buildChunkMesh(cx + 1, cz);
            if (lz === 0) this.buildChunkMesh(cx, cz - 1);
            if (lz === CHUNK_SIZE - 1) this.buildChunkMesh(cx, cz + 1);
          }
        }

        // ==================== MESH BUILDING ====================

        buildChunkMesh(cx, cz) {
          const key = `${cx},${cz}`;
          const chunk = this.chunks.get(key);
          if (!chunk) return;

          if (this.chunkMeshes.has(key)) {
            const oldGroup = this.chunkMeshes.get(key);
            this.scene.remove(oldGroup);
            oldGroup.children.forEach(mesh => {
              mesh.geometry.dispose();
              mesh.material.dispose();
            });
          }

          const opaque = { pos: [], col: [] };
          const trans = { pos: [], col: [] };

          const localGetBlock = (x, y, z) => {
            if (y < 0 || y >= WORLD_HEIGHT) return BLOCK.AIR;

            const lx = x - (cx * CHUNK_SIZE);
            const lz = z - (cz * CHUNK_SIZE);

            if (lx >= 0 && lx < CHUNK_SIZE && lz >= 0 && lz < CHUNK_SIZE) {
              const modKey = `${x},${y},${z}`;
              if (this.modifiedBlocks.has(modKey)) {
                return this.modifiedBlocks.get(modKey);
              }
              return chunk[lx + y * CHUNK_SIZE + lz * CHUNK_SIZE * WORLD_HEIGHT];
            }

            return this.getBlock(x, y, z);
          };

          const isOccluder = (x, y, z) => {
            const block = localGetBlock(x, y, z);
            return block !== BLOCK.AIR && !BLOCK_DATA[block]?.transparent;
          };

          const vertexAO = (s1, s2, c) => (s1 && s2) ? 0 : 3 - (s1 + s2 + c);
          const aoLevels = [0.5, 0.7, 0.85, 1.0];

          const addFace = (x, y, z, dir, color, target) => {
            const r = ((color >> 16) & 255) / 255;
            const g = ((color >> 8) & 255) / 255;
            const b = (color & 255) / 255;

            const face = FACE_DATA[dir];

            const ao = face.corners.map(c => {
              const s1 = isOccluder(x + c.neighbors[0][0], y + c.neighbors[0][1], z + c.neighbors[0][2]) ? 1 : 0;
              const s2 = isOccluder(x + c.neighbors[1][0], y + c.neighbors[1][1], z + c.neighbors[1][2]) ? 1 : 0;
              const corner = isOccluder(x + c.neighbors[2][0], y + c.neighbors[2][1], z + c.neighbors[2][2]) ? 1 : 0;
              return vertexAO(s1, s2, corner);
            });

            const flip = ao[0] + ao[2] < ao[1] + ao[3];
            const indices = flip ? [1, 2, 3, 1, 3, 0] : [0, 1, 2, 0, 2, 3];

            const noise = (Math.sin(x * 12.9898 + z * 78.233) * 43758.5453) % 1;
            const v = 1 - (Math.abs(noise) * 0.08);

            indices.forEach(i => {
              const corner = face.corners[i];
              target.pos.push(x + corner.pos[0], y + corner.pos[1], z + corner.pos[2]);
              const m = aoLevels[ao[i]] * face.shade * v;
              target.col.push(r * m, g * m, b * m);
            });
          };

          for (let lx = 0; lx < CHUNK_SIZE; lx++) {
            for (let y = 0; y < WORLD_HEIGHT; y++) {
              for (let lz = 0; lz < CHUNK_SIZE; lz++) {
                const wx = cx * CHUNK_SIZE + lx;
                const wz = cz * CHUNK_SIZE + lz;
                
                const modKey = `${wx},${y},${wz}`;
                let block;
                if (this.modifiedBlocks.has(modKey)) {
                  block = this.modifiedBlocks.get(modKey);
                } else {
                  const idx = lx + y * CHUNK_SIZE + lz * CHUNK_SIZE * WORLD_HEIGHT;
                  block = chunk[idx];
                }
                
                if (block === BLOCK.AIR) continue;

                const data = BLOCK_DATA[block];
                if (!data) continue;
                
                const target = data.transparent ? trans : opaque;

                const shouldRender = (nx, ny, nz) => {
                  const neighbor = localGetBlock(nx, ny, nz);
                  if (neighbor === BLOCK.AIR) return true;
                  const nData = BLOCK_DATA[neighbor];
                  if (!nData) return true;
                  if (nData.transparent && !data.transparent) return true;
                  if (data.transparent && nData.transparent && neighbor !== block) return true;
                  return false;
                };

                if (shouldRender(wx, y + 1, wz)) addFace(wx, y, wz, 'top', data.top, target);
                if (shouldRender(wx, y - 1, wz)) addFace(wx, y, wz, 'bottom', data.bottom, target);
                if (shouldRender(wx, y, wz + 1)) addFace(wx, y, wz, 'front', data.side, target);
                if (shouldRender(wx, y, wz - 1)) addFace(wx, y, wz, 'back', data.side, target);
                if (shouldRender(wx + 1, y, wz)) addFace(wx, y, wz, 'right', data.side, target);
                if (shouldRender(wx - 1, y, wz)) addFace(wx, y, wz, 'left', data.side, target);
              }
            }
          }

          const group = new THREE.Group();
          const createMesh = (data, isTrans) => {
            if (data.pos.length === 0) return;
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(data.pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(data.col, 3));
            geo.computeVertexNormals();
            const mat = new THREE.MeshStandardMaterial({ 
              vertexColors: true, 
              transparent: isTrans, 
              opacity: isTrans ? 0.6 : 1.0,
              depthWrite: !isTrans,
              roughness: 0.8,
              side: THREE.FrontSide
            });
            const mesh = new THREE.Mesh(geo, mat);
            
            if (this.settings.shadowsEnabled) {
              mesh.castShadow = !isTrans;
              mesh.receiveShadow = !isTrans;
            }
            group.add(mesh);
          };

          createMesh(opaque, false);
          createMesh(trans, true);
          this.scene.add(group);
          this.chunkMeshes.set(key, group);
        }

        // ==================== PLAYER & PHYSICS ====================

        updatePlayer(dt) {
          if (this.player.isDead) return;
          
          const moveDir = new THREE.Vector3();
          if (this.keys['KeyW'] || this.keys['ArrowUp']) moveDir.z -= 1;
          if (this.keys['KeyS'] || this.keys['ArrowDown']) moveDir.z += 1;
          if (this.keys['KeyA'] || this.keys['ArrowLeft']) moveDir.x -= 1;
          if (this.keys['KeyD'] || this.keys['ArrowRight']) moveDir.x += 1;
          moveDir.normalize();

          const cos = Math.cos(this.player.yaw);
          const sin = Math.sin(this.player.yaw);

          const moveX = moveDir.x * cos + moveDir.z * sin;
          const moveZ = -moveDir.x * sin + moveDir.z * cos;

          if (this.isFlying) {
            const flySpeed = this.keys['ShiftLeft'] ? FLY_SPEED * 2 : FLY_SPEED;
            this.player.velocity.x = moveX * flySpeed;
            this.player.velocity.z = moveZ * flySpeed;
            
            if (this.keys['Space']) {
              this.player.velocity.y = flySpeed;
            } else if (this.keys['ShiftLeft']) {
              this.player.velocity.y = -flySpeed;
            } else {
              this.player.velocity.y = 0;
            }
          } else {
            const speed = this.keys['ShiftLeft'] ? SPRINT_SPEED : WALK_SPEED;
            const waterMult = this.player.inWater ? 0.5 : 1;

            this.player.velocity.x = moveX * speed * waterMult;
            this.player.velocity.z = moveZ * speed * waterMult;

            if (this.keys['Space']) {
              if (this.player.onGround) {
                this.player.velocity.y = JUMP_FORCE;
                this.player.onGround = false;
              } else if (this.player.inWater) {
                this.player.velocity.y = 3;
              }
            }

            const grav = this.player.inWater ? GRAVITY * 0.3 : GRAVITY;
            this.player.velocity.y -= grav * dt;
            if (this.player.inWater) {
              this.player.velocity.y = Math.max(-3, this.player.velocity.y);
            }
          }

          // Track fall start for fall damage
          if (!this.player.onGround && !this.isFlying && !this.player.inWater) {
            if (this.player.fallStartY === null && this.player.velocity.y < 0) {
              this.player.fallStartY = this.player.position.y;
            }
          }

          const wasOnGround = this.player.onGround;
          this.moveWithCollision(dt);

          // Calculate fall damage when landing
          if (this.player.onGround && !wasOnGround && this.player.fallStartY !== null) {
            const fallDistance = this.player.fallStartY - this.player.position.y;
            this.applyFallDamage(fallDistance);
            this.player.fallStartY = null;
          }

          if (this.player.onGround || this.player.inWater || this.isFlying) {
            this.player.fallStartY = null;
          }

          const headBlock = this.getBlock(
            Math.floor(this.player.position.x),
            Math.floor(this.player.position.y),
            Math.floor(this.player.position.z)
          );
          this.player.inWater = headBlock === BLOCK.WATER;

          this.camera.position.copy(this.player.position);
          this.camera.rotation.order = 'YXZ';
          this.camera.rotation.y = this.player.yaw;
          this.camera.rotation.x = this.player.pitch;

          this.sun.position.set(
            this.player.position.x + 100,
            this.player.position.y + 200,
            this.player.position.z + 50
          );
          this.sunTarget.position.copy(this.player.position);

          const p = this.player.position;
          document.getElementById('position').textContent = 
            `XYZ: ${p.x.toFixed(1)} / ${p.y.toFixed(1)} / ${p.z.toFixed(1)}`;
        }

        applyFallDamage(fallDistance) {
          if (this.gameMode === 'creative') return;
          
          // Minecraft fall damage: damage = floor(fallDistance) - 3
          // You take damage after falling more than 3 blocks
          const damage = Math.floor(fallDistance) - 3;
          
          if (damage > 0) {
            this.player.health -= damage;
            this.updateHealthBar();
            
            // Screen shake effect could be added here
            
            if (this.player.health <= 0) {
              this.playerDie();
            }
          }
        }

        playerDie() {
          this.player.isDead = true;
          this.player.health = 0;
          this.updateHealthBar();
          
          // Drop all items (simplified - just clear inventory)
          // In a full implementation, items would drop as entities
          
          document.getElementById('death-screen').classList.add('visible');
          document.exitPointerLock();
        }

        respawn() {
          this.player.isDead = false;
          this.player.health = MAX_HEALTH;
          this.player.fallStartY = null;
          this.player.velocity.set(0, 0, 0);
          
          // Find new spawn point
          this.findSpawnPoint();
          
          // Clear inventory on death (Minecraft behavior)
          this.hotbarSlots.fill(null);
          this.inventorySlots.fill(null);
          
          this.updateHealthBar();
          this.updateHotbar();
          
          document.getElementById('death-screen').classList.remove('visible');
          
          setTimeout(() => {
            this.renderer.domElement.requestPointerLock();
          }, 100);
        }

        moveWithCollision(dt) {
          const pos = this.player.position;
          const vel = this.player.velocity;

          if (this.isFlying) {
            pos.x += vel.x * dt;
            pos.y += vel.y * dt;
            pos.z += vel.z * dt;
            return;
          }

          pos.x += vel.x * dt;
          if (this.checkCollision(pos)) { pos.x -= vel.x * dt; vel.x = 0; }

          pos.z += vel.z * dt;
          if (this.checkCollision(pos)) { pos.z -= vel.z * dt; vel.z = 0; }

          pos.y += vel.y * dt;
          if (this.checkCollision(pos)) {
            if (vel.y < 0) this.player.onGround = true;
            pos.y -= vel.y * dt;
            vel.y = 0;
          } else {
            this.player.onGround = false;
          }
        }

        checkCollision(pos) {
          const hw = PLAYER_WIDTH / 2;
          const corners = [
            [pos.x - hw, pos.y - PLAYER_HEIGHT, pos.z - hw],
            [pos.x + hw, pos.y - PLAYER_HEIGHT, pos.z - hw],
            [pos.x - hw, pos.y - PLAYER_HEIGHT, pos.z + hw],
            [pos.x + hw, pos.y - PLAYER_HEIGHT, pos.z + hw],
            [pos.x - hw, pos.y - 0.01, pos.z - hw],
            [pos.x + hw, pos.y - 0.01, pos.z - hw],
            [pos.x - hw, pos.y - 0.01, pos.z + hw],
            [pos.x + hw, pos.y - 0.01, pos.z + hw],
            [pos.x - hw, pos.y - PLAYER_HEIGHT/2, pos.z - hw],
            [pos.x + hw, pos.y - PLAYER_HEIGHT/2, pos.z + hw],
          ];

          for (const [x, y, z] of corners) {
            const block = this.getBlock(Math.floor(x), Math.floor(y), Math.floor(z));
            if (block !== BLOCK.AIR && BLOCK_DATA[block] && BLOCK_DATA[block].solid) {
              return true;
            }
          }
          return false;
        }

        // ==================== INTERACTION ====================

        updateBlockSelection() {
          const dir = new THREE.Vector3(0, 0, -1);
          dir.applyQuaternion(this.camera.quaternion);

          this.targetBlock = null;
          this.placementBlock = null;

          let prevX, prevY, prevZ;
          for (let t = 0; t < 5; t += 0.05) {
            const x = Math.floor(this.camera.position.x + dir.x * t);
            const y = Math.floor(this.camera.position.y + dir.y * t);
            const z = Math.floor(this.camera.position.z + dir.z * t);

            const block = this.getBlock(x, y, z);
            if (block !== BLOCK.AIR && block !== BLOCK.WATER) {
              this.targetBlock = { x, y, z };
              if (prevX !== undefined) {
                this.placementBlock = { x: prevX, y: prevY, z: prevZ };
              }
              break;
            }
            prevX = x; prevY = y; prevZ = z;
          }

          if (this.targetBlock) {
            this.highlight.position.set(
              this.targetBlock.x + 0.5,
              this.targetBlock.y + 0.5,
              this.targetBlock.z + 0.5
            );
            this.highlight.visible = true;
          } else {
            this.highlight.visible = false;
          }
        }

        canMineBlock(blockData, tool) {
          if (!blockData.minTool) return true;
          if (!tool) return false;
          
          const minTierIndex = TOOL_TIERS.indexOf(blockData.minTool);
          const toolTierIndex = TOOL_TIERS.indexOf(tool.toolTier);
          
          return toolTierIndex >= minTierIndex;
        }

        getMiningSpeed(blockData, tool) {
          if (!tool) return 1;
          
          // Check if this is the right tool type
          if (tool.toolType === blockData.toolType) {
            return tool.miningSpeed;
          }
          
          return 1;
        }

        breakBlock() {
          if (!this.targetBlock) return;

          const { x, y, z } = this.targetBlock;
          const block = this.getBlock(x, y, z);
          const blockData = BLOCK_DATA[block];
          
          if (block === BLOCK.BEDROCK) return;
          if (!blockData) return;

          const tool = this.getHeldTool();
          
          // Check if we can mine this block
          if (!this.canMineBlock(blockData, tool)) {
            // Can't mine, don't drop anything
            this.setBlock(x, y, z, BLOCK.AIR);
            this.spawnParticles(x + 0.5, y + 0.5, z + 0.5, blockData.side);
            return;
          }

          // Damage tool
          if (tool && this.gameMode === 'survival') {
            this.damageTool(tool.slotIndex);
          }

          // Determine what to drop
          let dropItem = block;
          let dropCount = 1;
          
          if (blockData.drops !== undefined) {
            if (blockData.drops === null) {
              // No drop (like glass)
              dropItem = null;
            } else {
              dropItem = blockData.drops;
            }
          } else if (block === BLOCK.STONE) {
            dropItem = BLOCK.COBBLE;
          }

          this.spawnParticles(x + 0.5, y + 0.5, z + 0.5, blockData.side);
          this.setBlock(x, y, z, BLOCK.AIR);
          
          // Add to inventory in survival mode
          if (this.gameMode === 'survival' && dropItem !== null) {
            this.addToInventory(dropItem, dropCount);
          }
          
          this.breakProgress = 0;
          this.currentBreakingBlock = null;
          this.updateBreakIndicator(0);
        }

        placeBlock() {
          if (!this.placementBlock) return;
          
          const heldItem = this.getHeldItem();
          if (!heldItem) return;
          
          // Check if held item is a placeable block
          if (!BLOCK_DATA[heldItem.id]) return;

          const { x, y, z } = this.placementBlock;
          const px = this.player.position.x;
          const py = this.player.position.y;
          const pz = this.player.position.z;

          const hw = PLAYER_WIDTH / 2;
          if (x >= Math.floor(px - hw) && x <= Math.floor(px + hw) &&
              z >= Math.floor(pz - hw) && z <= Math.floor(pz + hw) &&
              y >= Math.floor(py - PLAYER_HEIGHT) && y <= Math.floor(py)) {
            return;
          }

          // Remove from inventory in survival
          if (this.gameMode === 'survival') {
            if (heldItem.count <= 1) {
              this.hotbarSlots[this.selectedSlot] = null;
            } else {
              heldItem.count--;
            }
            this.updateHotbar();
          }

          this.setBlock(x, y, z, heldItem.id);
          this.placeCooldown = PLACE_COOLDOWN;
        }

        spawnParticles(x, y, z, color) {
          for (let i = 0; i < 25; i++) {
            const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const mat = new THREE.MeshBasicMaterial({ color });
            const particle = new THREE.Mesh(geo, mat);
            particle.position.set(
              x + (Math.random() - 0.5) * 0.5,
              y + (Math.random() - 0.5) * 0.5,
              z + (Math.random() - 0.5) * 0.5
            );
            particle.velocity = new THREE.Vector3(
              (Math.random() - 0.5) * 3,
              Math.random() * 3 + 1,
              (Math.random() - 0.5) * 3
            );
            particle.life = 2.0 + Math.random() * 1.0;
            particle.maxLife = particle.life;
            this.scene.add(particle);
            this.particleSystem.push(particle);
          }
        }

        updateParticles(dt) {
          for (let i = this.particleSystem.length - 1; i >= 0; i--) {
            const p = this.particleSystem[i];
            
            p.velocity.y -= 15 * dt;
            
            const newX = p.position.x + p.velocity.x * dt;
            const newY = p.position.y + p.velocity.y * dt;
            const newZ = p.position.z + p.velocity.z * dt;
            
            const blockX = Math.floor(newX);
            const blockY = Math.floor(newY);
            const blockZ = Math.floor(newZ);
            
            const block = this.getBlock(blockX, blockY, blockZ);
            if (block !== BLOCK.AIR && BLOCK_DATA[block]?.solid) {
              if (this.getBlock(Math.floor(p.position.x), blockY, Math.floor(p.position.z)) !== BLOCK.AIR) {
                p.velocity.y = -p.velocity.y * 0.3;
                p.velocity.x *= 0.7;
                p.velocity.z *= 0.7;
              } else if (this.getBlock(blockX, Math.floor(p.position.y), Math.floor(p.position.z)) !== BLOCK.AIR) {
                p.velocity.x = -p.velocity.x * 0.3;
              } else if (this.getBlock(Math.floor(p.position.x), Math.floor(p.position.y), blockZ) !== BLOCK.AIR) {
                p.velocity.z = -p.velocity.z * 0.3;
              }
            } else {
              p.position.set(newX, newY, newZ);
            }
            
            p.life -= dt;
            
            const lifeRatio = p.life / p.maxLife;
            p.scale.setScalar(0.5 + lifeRatio * 0.5);
            p.material.opacity = lifeRatio;
            p.material.transparent = true;

            if (p.life <= 0) {
              this.scene.remove(p);
              p.geometry.dispose();
              p.material.dispose();
              this.particleSystem.splice(i, 1);
            }
          }
        }

        // ==================== CHUNK MANAGEMENT ====================

        updateChunks() {
          const pcx = Math.floor(this.player.position.x / CHUNK_SIZE);
          const pcz = Math.floor(this.player.position.z / CHUNK_SIZE);

          const chunksNeeded = [];
          for (let dx = -this.settings.renderDistance; dx <= this.settings.renderDistance; dx++) {
            for (let dz = -this.settings.renderDistance; dz <= this.settings.renderDistance; dz++) {
              const distSq = dx*dx + dz*dz;
              if (distSq <= this.settings.renderDistance * this.settings.renderDistance) {
                const cx = pcx + dx;
                const cz = pcz + dz;
                const key = `${cx},${cz}`;
                if (!this.chunks.has(key)) {
                  chunksNeeded.push({cx, cz, dist: distSq});
                }
              }
            }
          }
          
          chunksNeeded.sort((a, b) => a.dist - b.dist);
          const maxChunksPerFrame = 2;
          for (let i = 0; i < Math.min(chunksNeeded.length, maxChunksPerFrame); i++) {
            this.generateChunk(chunksNeeded[i].cx, chunksNeeded[i].cz);
          }

          const maxDist = this.settings.renderDistance + 2;
          this.chunkMeshes.forEach((group, key) => {
            const [cx, cz] = key.split(',').map(Number);
            if (Math.abs(cx - pcx) > maxDist || Math.abs(cz - pcz) > maxDist) {
              this.scene.remove(group);
              group.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
              });
              this.chunkMeshes.delete(key);
              this.chunks.delete(key);
            }
          });

          document.getElementById('chunk-info').textContent = `Chunks: ${this.chunkMeshes.size}`;
        }

        // ==================== GAME LOOP ====================

        gameLoop() {
          if (!this.isPlaying) return;

          const now = performance.now();
          const dt = Math.min((now - this.lastTime) / 1000, 0.1);
          this.lastTime = now;

          this.frameCount++;
          if (now - this.fpsTime >= 1000) {
            this.fps = this.frameCount;
            this.frameCount = 0;
            this.fpsTime = now;
            document.getElementById('fps').textContent = `FPS: ${this.fps}`;
          }

          if (document.pointerLockElement && !this.isPaused && !this.inventoryOpen && !this.player.isDead) {
            this.updatePlayer(dt);
            this.updateBlockSelection();

            if (this.breaking && this.targetBlock) {
              const blockKey = `${this.targetBlock.x},${this.targetBlock.y},${this.targetBlock.z}`;
              
              if (this.currentBreakingBlock !== blockKey) {
                this.breakProgress = 0;
                this.currentBreakingBlock = blockKey;
              }
              
              const block = this.getBlock(this.targetBlock.x, this.targetBlock.y, this.targetBlock.z);
              const blockData = BLOCK_DATA[block];
              
              if (blockData && blockData.hardness > 0) {
                if (this.gameMode === 'creative') {
                  this.breakBlock();
                } else {
                  const tool = this.getHeldTool();
                  const miningSpeed = this.getMiningSpeed(blockData, tool);
                  const breakSpeed = miningSpeed / blockData.hardness;
                  
                  this.breakProgress += dt * breakSpeed;
                  this.updateBreakIndicator(this.breakProgress);
                  
                  if (this.breakProgress >= 1) {
                    this.breakBlock();
                  }
                }
              } else if (blockData && blockData.hardness === -1) {
                this.breakProgress = 0;
                this.updateBreakIndicator(0);
              }
            } else {
              if (this.breakProgress > 0) {
                this.breakProgress = 0;
                this.currentBreakingBlock = null;
                this.updateBreakIndicator(0);
              }
            }

            if (this.placing) {
              this.placeCooldown -= dt;
              if (this.placeCooldown <= 0) {
                this.placeBlock();
              }
            }

            this.updateChunks();
          }

          this.updateParticles(dt);
          this.renderer.render(this.scene, this.camera);
          requestAnimationFrame(() => this.gameLoop());
        }
      }

      // Start
      const game = new MinecraftGame();
    </script>
  </body>
</html>
