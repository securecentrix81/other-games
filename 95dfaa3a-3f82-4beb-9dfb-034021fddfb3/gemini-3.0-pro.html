<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saharsh's Class Failing Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; user-select: none; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        .hud-panel { padding: 20px; display: flex; gap: 20px; }
        .stat-box { background: rgba(0, 0, 0, 0.7); color: white; padding: 10px 20px; border-radius: 8px; border: 2px solid #444; min-width: 150px; }
        .stat-label { font-size: 12px; color: #aaa; text-transform: uppercase; letter-spacing: 1px; }
        .stat-value { font-size: 24px; font-weight: bold; }
        .stat-value.danger { color: #ef4444; }
        .stat-value.success { color: #22c55e; }
        
        #start-screen, #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 10;
            color: white; text-align: center;
        }
        
        .btn {
            background: linear-gradient(45deg, #3b82f6, #2563eb);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
            transition: transform 0.1s, box-shadow 0.1s;
            text-transform: uppercase;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.5);
        }
        .btn:hover { transform: scale(1.05); box-shadow: 0 6px 20px rgba(59, 130, 246, 0.7); }
        .btn:active { transform: scale(0.95); }

        /* Retro CRT effect overlay */
        .scanlines {
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px;
            position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 5;
        }
    </style>
</head>
<body>
    <!-- UI Layer -->
    <div id="game-ui">
        <div class="hud-panel" style="align-items: flex-start;">
            <div class="stat-box">
                <div class="stat-label">GPA (Health)</div>
                <div class="stat-value danger" id="gpa-display">4.0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Classes Failed</div>
                <div class="stat-value success" id="score-display">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Distraction Level</div>
                <div class="stat-value" id="distraction-display">0%</div>
            </div>
        </div>
        <div class="hud-panel" style="justify-content: flex-end; align-items: flex-end;">
            <div style="color: white; opacity: 0.7; font-size: 14px; text-align: right;">
                WASD / Arrows to Move<br>Space to Jump<br>Avoid Homework & Teachers<br>Collect Laptops
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1 class="text-6xl font-bold mb-2 text-blue-400" style="text-shadow: 0 0 20px rgba(59,130,246,0.5);">SAHARSH'S CLASS FAILING GAME</h1>
        <p class="text-xl mb-8 max-w-2xl text-gray-300">You are Saharsh. You need to fail your classes by playing on <strong>Secure Centrix</strong>.<br>Collect laptops to gain distraction points. Avoid homework and teachers or your GPA will go up!</p>
        <div class="flex gap-4">
            <button class="btn" onclick="startGame()">Start Failing</button>
        </div>
        <div class="mt-8 text-sm text-gray-500">Texture: Saharsh loaded</div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" style="display: none;">
        <h1 class="text-5xl font-bold mb-4 text-red-500">YOU GRADUATED! (GAME OVER)</h1>
        <p class="text-xl mb-6">You accidentally learned too much. Your GPA is too high.</p>
        <div class="stat-box mb-6">
            <div class="stat-label">Final Classes Failed</div>
            <div class="stat-value success" id="final-score">0</div>
        </div>
        <button class="btn" onclick="resetGame()">Try To Fail Again</button>
    </div>

    <div class="scanlines"></div>

    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Game State ---
        let state = {
            isPlaying: false,
            score: 0, // Classes Failed
            gpa: 0.0, // Health (Starts at 0.0 "F", increases to 4.0 "A". 4.0 = Death)
            distraction: 0, // Progress to failing a class
            time: 0,
            difficulty: 1
        };

        // --- Configuration ---
        const SAHARSH_TEXTURE_URL = 'https://asset-cdn.schoology.com/system/files/imagecache/profile_big/pictures/picture-c0b09cdead19788fb0f8be0d53b5c572_68c34cd700b90.jpg';
        
        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111827); // Dark blue-gray like a dark classroom
        scene.fog = new THREE.FogExp2(0x111827, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- Materials & Textures ---
        const textureLoader = new THREE.TextureLoader();
        const saharshTexture = textureLoader.load(SAHARSH_TEXTURE_URL);
        saharshTexture.colorSpace = THREE.SRGBColorSpace;
        
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x334155, 
            roughness: 0.8,
            metalness: 0.2
        });
        
        // Grid pattern for floor
        const gridTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/uv_grid_opengl.jpg');
        gridTexture.wrapS = THREE.RepeatWrapping;
        gridTexture.wrapT = THREE.RepeatWrapping;
        gridTexture.repeat.set(20, 20);
        // floorMaterial.map = gridTexture; // Optional: Use simple color for cleaner look

        // --- Game Objects ---
        const player = {
            mesh: null,
            velocity: new THREE.Vector3(),
            speed: 15,
            isGrounded: false
        };

        const enemies = [];
        const collectibles = [];
        const particles = [];

        // Arena Boundaries
        const ARENA_SIZE = 40;

        function createEnvironment() {
            // Floor
            const floorGeo = new THREE.PlaneGeometry(ARENA_SIZE * 2, ARENA_SIZE * 2);
            const floor = new THREE.Mesh(floorGeo, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Walls (Classroom vibe)
            const wallHeight = 5;
            const wallGeo = new THREE.BoxGeometry(ARENA_SIZE * 2, wallHeight, 1);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x1e293b });

            const walls = [
                { pos: [0, wallHeight/2, -ARENA_SIZE], rot: [0, 0, 0] },
                { pos: [0, wallHeight/2, ARENA_SIZE], rot: [0, 0, 0] },
                { pos: [-ARENA_SIZE, wallHeight/2, 0], rot: [0, Math.PI/2, 0] },
                { pos: [ARENA_SIZE, wallHeight/2, 0], rot: [0, Math.PI/2, 0] }
            ];

            walls.forEach(w => {
                const wall = new THREE.Mesh(wallGeo, wallMat);
                wall.position.set(...w.pos);
                wall.rotation.set(...w.rot);
                wall.receiveShadow = true;
                wall.castShadow = true;
                scene.add(wall);
            });
            
            // Desks (Obstacles that aren't enemies)
            const deskGeo = new THREE.BoxGeometry(2, 1.5, 1);
            const deskMat = new THREE.MeshStandardMaterial({ color: 0x7c2d12 }); // Brown wood
            
            for(let i=0; i<15; i++) {
                const desk = new THREE.Mesh(deskGeo, deskMat);
                desk.position.x = (Math.random() - 0.5) * ARENA_SIZE * 1.5;
                desk.position.z = (Math.random() - 0.5) * ARENA_SIZE * 1.5;
                desk.position.y = 0.75;
                desk.castShadow = true;
                desk.receiveShadow = true;
                scene.add(desk);
            }
        }

        function createPlayer() {
            const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const materials = [
                new THREE.MeshBasicMaterial({ map: saharshTexture }), // Right
                new THREE.MeshBasicMaterial({ map: saharshTexture }), // Left
                new THREE.MeshBasicMaterial({ color: 0x000000 }), // Top (Hair?)
                new THREE.MeshBasicMaterial({ color: 0x000000 }), // Bottom
                new THREE.MeshBasicMaterial({ map: saharshTexture }), // Front
                new THREE.MeshBasicMaterial({ map: saharshTexture })  // Back
            ];
            
            player.mesh = new THREE.Mesh(geometry, materials);
            player.mesh.position.y = 1;
            player.mesh.castShadow = true;
            scene.add(player.mesh);
        }

        // --- Spawners ---
        
        function spawnEnemy() {
            const type = Math.random() > 0.5 ? 'book' : 'teacher';
            let geometry, material, mesh;

            if (type === 'book') {
                geometry = new THREE.BoxGeometry(0.8, 1, 0.2);
                material = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red book
                mesh = new THREE.Mesh(geometry, material);
            } else {
                geometry = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
                material = new THREE.MeshStandardMaterial({ color: 0x4b5563 }); // Grey suit
                mesh = new THREE.Mesh(geometry, material);
            }

            // Spawn away from player
            const angle = Math.random() * Math.PI * 2;
            const radius = 20 + Math.random() * 10;
            mesh.position.x = player.mesh.position.x + Math.cos(angle) * radius;
            mesh.position.z = player.mesh.position.z + Math.sin(angle) * radius;
            mesh.position.y = 1;
            
            // Clamp to arena
            mesh.position.x = Math.max(-ARENA_SIZE + 2, Math.min(ARENA_SIZE - 2, mesh.position.x));
            mesh.position.z = Math.max(-ARENA_SIZE + 2, Math.min(ARENA_SIZE - 2, mesh.position.z));

            mesh.castShadow = true;
            scene.add(mesh);

            enemies.push({
                mesh: mesh,
                type: type,
                speed: type === 'book' ? 6 : 4,
                rotationSpeed: Math.random() * 0.1
            });
        }

        function spawnCollectible() {
            // Laptop / Secure Centrix Terminal
            const geometry = new THREE.BoxGeometry(1, 0.1, 0.8);
            // Simple laptop shape using a group? Let's just do a glowing cube for simplicity/performance
            const simpleGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x22c55e, 
                emissive: 0x22c55e, 
                emissiveIntensity: 0.5 
            });
            
            const mesh = new THREE.Mesh(simpleGeo, material);
            
            mesh.position.x = (Math.random() - 0.5) * ARENA_SIZE * 1.8;
            mesh.position.z = (Math.random() - 0.5) * ARENA_SIZE * 1.8;
            mesh.position.y = 1;
            
            mesh.castShadow = true;
            scene.add(mesh);

            // Add a point light to it
            const light = new THREE.PointLight(0x22c55e, 1, 5);
            mesh.add(light);

            collectibles.push({
                mesh: mesh,
                bobOffset: Math.random() * Math.PI * 2
            });
        }

        function createExplosion(position, color) {
            const count = 10;
            for(let i=0; i<count; i++) {
                const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(position);
                
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5),
                    (Math.random() - 0.5) + 1,
                    (Math.random() - 0.5)
                ).normalize().multiplyScalar(Math.random() * 10);
                
                scene.add(mesh);
                particles.push({
                    mesh: mesh,
                    velocity: vel,
                    life: 1.0
                });
            }
        }

        // --- Input Handling ---
        const keys = { w: false, a: false, s: false, d: false, ' ': false };
        
        window.addEventListener('keydown', (e) => {
            if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true;
            if(e.key === ' ' && !state.isPlaying && document.getElementById('start-screen').style.display !== 'none') startGame();
        });
        
        window.addEventListener('keyup', (e) => {
            if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false;
        });

        // --- Game Logic ---

        function updatePlayer(dt) {
            if (!player.mesh) return;

            // Movement input relative to camera would be nice, but let's stick to world space for simplicity first
            // Actually, let's do world space relative to camera orientation
            
            const moveDir = new THREE.Vector3(0, 0, 0);
            if (keys.w) moveDir.z -= 1;
            if (keys.s) moveDir.z += 1;
            if (keys.a) moveDir.x -= 1;
            if (keys.d) moveDir.x += 1;

            if (moveDir.length() > 0) {
                moveDir.normalize();
                player.velocity.x = moveDir.x * player.speed;
                player.velocity.z = moveDir.z * player.speed;
                
                // Rotate player to face direction
                const angle = Math.atan2(player.velocity.x, player.velocity.z);
                player.mesh.rotation.y = angle;
            } else {
                // Friction
                player.velocity.x *= 0.8;
                player.velocity.z *= 0.8;
            }

            // Gravity and Jump
            /* 
            if (keys[' '] && player.isGrounded) {
                player.velocity.y = 15;
                player.isGrounded = false;
            }
            */
           // Simplified physics:
            player.velocity.y = 0; 
            player.mesh.position.y = 1; // Keep on ground

            // Apply Velocity
            player.mesh.position.x += player.velocity.x * dt;
            player.mesh.position.z += player.velocity.z * dt;
            // player.mesh.position.y += player.velocity.y * dt;

            // Boundary Check
            const limit = ARENA_SIZE - 1;
            player.mesh.position.x = Math.max(-limit, Math.min(limit, player.mesh.position.x));
            player.mesh.position.z = Math.max(-limit, Math.min(limit, player.mesh.position.z));
            
            // Floor check
            /*
            if (player.mesh.position.y < 1) {
                player.mesh.position.y = 1;
                player.velocity.y = 0;
                player.isGrounded = true;
            }
            */

            // Camera Follow
            const targetCamPos = new THREE.Vector3(
                player.mesh.position.x,
                player.mesh.position.y + 15,
                player.mesh.position.z + 15
            );
            camera.position.lerp(targetCamPos, 0.1);
            camera.lookAt(player.mesh.position);
        }

        function updateEnemies(dt) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dir = new THREE.Vector3()
                    .subVectors(player.mesh.position, enemy.mesh.position)
                    .normalize();
                
                enemy.mesh.position.add(dir.multiplyScalar(enemy.speed * dt));
                
                if (enemy.type === 'book') {
                    enemy.mesh.rotation.x += enemy.rotationSpeed * 100 * dt;
                    enemy.mesh.rotation.y += enemy.rotationSpeed * 100 * dt;
                } else {
                    enemy.mesh.lookAt(player.mesh.position);
                }

                // Collision with Player
                const dist = enemy.mesh.position.distanceTo(player.mesh.position);
                if (dist < 1.5) {
                    // Hit!
                    state.gpa += 0.5; // GPA goes up (bad)
                    updateUI();
                    createExplosion(enemy.mesh.position, 0xff0000);
                    
                    // Remove enemy
                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                    
                    // Screenshake maybe?
                    camera.position.x += (Math.random() - 0.5) * 2;

                    if (state.gpa >= 4.0) {
                        gameOver();
                    }
                }
            }
        }

        function updateCollectibles(dt) {
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const item = collectibles[i];
                item.mesh.rotation.y += dt;
                item.mesh.position.y = 1 + Math.sin(state.time * 2 + item.bobOffset) * 0.3;

                const dist = item.mesh.position.distanceTo(player.mesh.position);
                if (dist < 2.0) {
                    // Collect!
                    state.distraction += 25;
                    if (state.distraction >= 100) {
                        state.distraction = 0;
                        state.score += 1; // Class Failed!
                        
                        // Heal GPA slightly (failing heals the soul in this game)
                        state.gpa = Math.max(0, state.gpa - 0.5);
                    }
                    
                    updateUI();
                    createExplosion(item.mesh.position, 0x22c55e);
                    
                    scene.remove(item.mesh);
                    collectibles.splice(i, 1);
                }
            }
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= dt;
                p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));
                p.mesh.rotation.x += dt * 2;
                p.mesh.scale.setScalar(p.life);
                
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        function updateUI() {
            const gpa = Math.min(4.0, Math.max(0.0, state.gpa)).toFixed(1);
            const gpaEl = document.getElementById('gpa-display');
            gpaEl.innerText = gpa;
            
            // Color coding GPA
            if (gpa < 2.0) gpaEl.className = 'stat-value success';
            else if (gpa < 3.0) gpaEl.className = 'stat-value';
            else gpaEl.className = 'stat-value danger';
            
            // Fail conditions logic:
            // In this game, 4.0 GPA is DEATH (You studied too much)
            // 0.0 GPA is PERFECT HEALTH
            
            document.getElementById('score-display').innerText = state.score;
            document.getElementById('distraction-display').innerText = Math.floor(state.distraction) + '%';
        }

        function gameLoop() {
            requestAnimationFrame(gameLoop);
            
            if (!state.isPlaying) {
                renderer.render(scene, camera);
                return;
            }

            const dt = 0.016; // Fixed step for simplicity
            state.time += dt;

            updatePlayer(dt);
            updateEnemies(dt);
            updateCollectibles(dt);
            updateParticles(dt);

            // Spawning Logic
            if (Math.random() < 0.01 + (state.score * 0.002)) {
                spawnEnemy();
            }
            
            if (collectibles.length < 3 + Math.floor(state.score / 2)) {
                if (Math.random() < 0.05) spawnCollectible();
            }

            renderer.render(scene, camera);
        }

        // --- Game Control Functions ---
        
        window.startGame = function() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            
            // Reset State
            state.score = 0;
            state.gpa = 0.0; // Starts at F (Good!)
            state.distraction = 0;
            state.isPlaying = true;
            
            // Clear Scene Entities
            enemies.forEach(e => scene.remove(e.mesh));
            enemies.length = 0;
            
            collectibles.forEach(c => scene.remove(c.mesh));
            collectibles.length = 0;
            
            particles.forEach(p => scene.remove(p.mesh));
            particles.length = 0;

            // Reset Player
            player.mesh.position.set(0, 1, 0);
            player.velocity.set(0, 0, 0);
            
            updateUI();
        };

        function gameOver() {
            state.isPlaying = false;
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('final-score').innerText = state.score;
        }

        window.resetGame = function() {
            startGame();
        };

        // --- Initialization ---
        createEnvironment();
        createPlayer();
        gameLoop();
        
        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
