<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red Dead Redemption 2: 1899 Showdown</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rye&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Rye', serif; /* Western style font */
            color: #fff;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        .ui-overlay {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        /* Scanlines/Old Film Effect */
        .film-grain {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 60%, black 100%), 
                        repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.1) 3px);
            pointer-events: none;
            z-index: 10;
        }

        .sepia-filter {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(112, 66, 20, 0.1);
            mix-blend-mode: overlay;
            pointer-events: none;
            z-index: 9;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Film Effects -->
        <div class="sepia-filter"></div>
        <div class="film-grain"></div>

        <!-- UI Layer -->
        <div class="ui-overlay flex flex-col justify-between p-6">
            
            <!-- Top Bar -->
            <div class="flex justify-between items-start">
                <div class="bg-black/50 p-4 rounded-lg border-2 border-[#8B4513]">
                    <h1 class="text-2xl text-[#FFA500] drop-shadow-md">BOUNTY: $<span id="score">0</span></h1>
                    <p class="text-sm text-gray-300">WAVE: <span id="wave">1</span></p>
                </div>
                
                <div class="text-right bg-black/50 p-4 rounded-lg border-2 border-[#8B4513]">
                    <div class="text-xl text-red-500 mb-1">DEAD EYE</div>
                    <div class="w-48 h-4 bg-gray-800 border border-gray-600 relative">
                        <div id="deadeye-bar" class="h-full bg-red-600 w-0 transition-all duration-100"></div>
                    </div>
                    <p class="text-xs text-gray-400 mt-1">Press SPACE to Toggle</p>
                </div>
            </div>

            <!-- Center Messages -->
            <div id="center-msg" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center transition-opacity duration-500 opacity-0">
                <h2 id="msg-title" class="text-6xl text-red-600 tracking-widest drop-shadow-[0_5px_5px_rgba(0,0,0,0.8)]">DEAD</h2>
                <p id="msg-sub" class="text-2xl text-white mt-2">Click to Restart</p>
            </div>

            <!-- Bottom Bar -->
            <div class="flex justify-between items-end">
                <!-- Health -->
                <div class="relative w-24 h-24">
                    <svg class="w-full h-full transform -rotate-90">
                        <circle cx="48" cy="48" r="40" stroke="#333" stroke-width="8" fill="none" />
                        <circle id="health-ring" cx="48" cy="48" r="40" stroke="#cc0000" stroke-width="8" fill="none" stroke-dasharray="251" stroke-dashoffset="0" />
                    </svg>
                    <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-2xl font-bold">
                        HP
                    </div>
                </div>

                <!-- Ammo -->
                <div class="flex flex-col items-end bg-black/50 p-4 rounded-lg border-2 border-[#8B4513]">
                    <div class="flex gap-2 mb-2" id="ammo-container">
                        <!-- Bullets injected here -->
                    </div>
                    <div class="text-xl text-[#FFA500]">REVOLVER</div>
                    <div class="text-xs text-gray-400">R to Reload</div>
                </div>
            </div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="absolute inset-0 bg-black/80 z-50 flex flex-col items-center justify-center text-center">
            <h1 class="text-6xl text-red-600 mb-4 tracking-widest" style="text-shadow: 4px 4px 0 #000;">RED DEAD 1899</h1>
            <p class="text-xl text-[#FFA500] mb-8 max-w-md">
                You are Arthur, an outlaw in a fading age. 
                Defend your camp from the Pinkertons and bounty hunters.
            </p>
            <div class="bg-[#8B4513] p-6 rounded-lg border-2 border-[#FFA500] max-w-lg shadow-2xl">
                <p class="mb-2 text-lg">WASD / Arrows to Move</p>
                <p class="mb-2 text-lg">Mouse to Aim & Shoot</p>
                <p class="mb-2 text-lg">R to Reload</p>
                <p class="mb-4 text-lg">SPACE for DEAD EYE (Slow Motion)</p>
                <button id="start-btn" class="bg-red-700 hover:bg-red-600 text-white font-bold py-3 px-8 rounded text-2xl shadow-lg border-2 border-black transition-transform transform hover:scale-105 active:scale-95">
                    RIDE OUT
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Game Configuration & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let gameLoopId;
        let lastTime = 0;
        
        const gameState = {
            active: false,
            paused: false,
            gameOver: false,
            score: 0,
            wave: 1,
            timeScale: 1.0, // For Dead Eye
            deadEyeMeter: 0, // 0 to 100
            deadEyeActive: false,
            lastShotTime: 0,
            reloadTime: 0
        };

        const keys = {
            w: false, a: false, s: false, d: false,
            ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false,
            r: false, ' ': false
        };

        const mouse = { x: 0, y: 0, down: false };

        // --- Entities ---
        let player;
        let bullets = [];
        let enemies = [];
        let particles = [];
        let props = []; // Buildings/Cacti

        // --- Constants ---
        const PLAYER_SPEED = 200;
        const ENEMY_SPEED = 100;
        const BULLET_SPEED = 800;
        const FIRE_RATE = 0.4; // seconds
        const RELOAD_TIME = 1.5; // seconds
        const MAX_AMMO = 6;
        const MAX_DEAD_EYE = 100;
        const DEAD_EYE_DRAIN = 30; // per second
        const DEAD_EYE_GAIN = 20; // per kill
        
        // --- Resize Handler ---
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Input Listeners ---
        window.addEventListener('keydown', e => {
            if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) {
                keys[e.key] = true;
                keys[e.key.toLowerCase()] = true;
            }
            if (e.key.toLowerCase() === 'r') player?.reload();
            if (e.key === ' ') toggleDeadEye();
        });

        window.addEventListener('keyup', e => {
            if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) {
                keys[e.key] = false;
                keys[e.key.toLowerCase()] = false;
            }
        });

        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        window.addEventListener('mousedown', () => mouse.down = true);
        window.addEventListener('mouseup', () => mouse.down = false);

        document.getElementById('start-btn').addEventListener('click', startGame);
        
        canvas.addEventListener('click', () => {
            if (gameState.gameOver) {
                startGame();
            }
        });

        // --- Classes ---

        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { return new Vector(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
            mult(n) { return new Vector(this.x * n, this.y * n); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            norm() { 
                const m = this.mag(); 
                return m === 0 ? new Vector(0,0) : new Vector(this.x / m, this.y / m); 
            }
        }

        class Player {
            constructor() {
                this.pos = new Vector(width / 2, height / 2);
                this.radius = 20;
                this.hp = 100;
                this.ammo = MAX_AMMO;
                this.reloading = false;
                this.angle = 0;
            }

            update(dt) {
                if (this.hp <= 0) return;

                let move = new Vector(0, 0);
                if (keys.w || keys.ArrowUp) move.y -= 1;
                if (keys.s || keys.ArrowDown) move.y += 1;
                if (keys.a || keys.ArrowLeft) move.x -= 1;
                if (keys.d || keys.ArrowRight) move.x += 1;

                // Normalize for diagonal movement
                if (move.mag() > 0) {
                    move = move.norm().mult(PLAYER_SPEED * dt);
                    this.pos = this.pos.add(move);
                }

                // Constrain to map
                this.pos.x = Math.max(this.radius, Math.min(width - this.radius, this.pos.x));
                this.pos.y = Math.max(this.radius, Math.min(height - this.radius, this.pos.y));

                // Aim
                const dx = mouse.x - this.pos.x;
                const dy = mouse.y - this.pos.y;
                this.angle = Math.atan2(dy, dx);

                // Shoot
                if (mouse.down && !this.reloading && this.ammo > 0) {
                    const now = Date.now() / 1000;
                    // Fire rate depends on dead eye (faster relative to world if slowed, but let's keep it simple)
                    if (now - gameState.lastShotTime > FIRE_RATE * (gameState.deadEyeActive ? 0.5 : 1)) {
                        this.shoot();
                        gameState.lastShotTime = now;
                    }
                } else if (mouse.down && this.ammo === 0 && !this.reloading) {
                    this.reload();
                }
            }

            shoot() {
                this.ammo--;
                updateAmmoUI();
                
                // Screenshake
                screenShake(5);

                // Spawn Bullet
                const dir = new Vector(Math.cos(this.angle), Math.sin(this.angle));
                const startPos = this.pos.add(dir.mult(30)); // Offset to gun
                bullets.push(new Bullet(startPos.x, startPos.y, dir, true));

                // Muzzle Flash
                createParticles(startPos.x, startPos.y, 5, '#FFFF00', 2);
            }

            reload() {
                if (this.reloading || this.ammo === MAX_AMMO) return;
                this.reloading = true;
                gameState.reloadTime = Date.now();
                
                // Show reloading text
                const reloadText = document.createElement('div');
                reloadText.innerText = "RELOADING...";
                reloadText.style.position = "absolute";
                reloadText.style.left = mouse.x + "px";
                reloadText.style.top = mouse.y + "px";
                reloadText.style.color = "white";
                reloadText.style.pointerEvents = "none";
                document.body.appendChild(reloadText);
                setTimeout(() => reloadText.remove(), 1000);

                setTimeout(() => {
                    this.ammo = MAX_AMMO;
                    this.reloading = false;
                    updateAmmoUI();
                }, RELOAD_TIME * 1000);
            }

            draw() {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle);

                // Shadow
                ctx.beginPath();
                ctx.arc(2, 2, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fill();

                // Body (Cowboy hat from top)
                ctx.fillStyle = '#3b2f2f'; // Dark brown coat
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Hat Brim
                ctx.fillStyle = '#8B4513'; // Saddle brown
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius + 4, this.radius - 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Hat Top
                ctx.fillStyle = '#5D4037';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius - 8, 0, Math.PI * 2);
                ctx.fill();

                // Arms/Gun
                ctx.fillStyle = '#3b2f2f';
                ctx.beginPath();
                ctx.rect(10, 5, 20, 8); // Right arm
                ctx.fill();

                // Revolver
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.rect(28, 4, 12, 4);
                ctx.fill();

                ctx.restore();
                
                // Reload bar if reloading
                if (this.reloading) {
                    const pct = (Date.now() - gameState.reloadTime) / (RELOAD_TIME * 1000);
                    ctx.fillStyle = 'white';
                    ctx.fillRect(this.pos.x - 20, this.pos.y - 40, 40 * Math.min(1, pct), 5);
                }
            }
        }

        class Enemy {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.radius = 18;
                this.hp = 2; // Takes 2 shots
                this.angle = 0;
                this.lastShot = 0;
                this.fireRate = 2 + Math.random() * 2; // Slower than player
                this.color = Math.random() > 0.5 ? '#4a0404' : '#1e3a8a'; // Red or Blue vests
            }

            update(dt) {
                if (this.hp <= 0) return;

                // Move towards player
                const dir = player.pos.sub(this.pos);
                const dist = dir.mag();
                this.angle = Math.atan2(dir.y, dir.x);

                // Stop if close enough to shoot
                if (dist > 150) {
                    const move = dir.norm().mult(ENEMY_SPEED * dt * gameState.timeScale);
                    this.pos = this.pos.add(move);
                }

                // Shoot
                const now = Date.now() / 1000;
                if (now - this.lastShot > this.fireRate / gameState.timeScale && dist < 400) {
                    this.shoot();
                    this.lastShot = now;
                }
            }

            shoot() {
                const dir = new Vector(Math.cos(this.angle), Math.sin(this.angle));
                // Inaccuracy
                const spread = 0.2;
                const finalAngle = this.angle + (Math.random() - 0.5) * spread;
                const finalDir = new Vector(Math.cos(finalAngle), Math.sin(finalAngle));
                
                const startPos = this.pos.add(finalDir.mult(25));
                bullets.push(new Bullet(startPos.x, startPos.y, finalDir, false));
            }

            draw() {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle);

                // Body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Bandana/Face mask
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.moveTo(0, -this.radius + 5);
                ctx.lineTo(10, 0);
                ctx.lineTo(0, this.radius - 5);
                ctx.fill();

                // Hat
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius + 2, this.radius - 4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Gun Arm
                ctx.fillStyle = this.color;
                ctx.fillRect(10, 5, 15, 6);
                
                // Gun
                ctx.fillStyle = '#111';
                ctx.fillRect(25, 4, 10, 3);

                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, dir, isPlayer) {
                this.pos = new Vector(x, y);
                this.dir = dir;
                this.isPlayer = isPlayer;
                this.speed = BULLET_SPEED;
                this.active = true;
                this.trail = [];
            }

            update(dt) {
                if (!this.active) return;

                // Add trail point
                this.trail.push({x: this.pos.x, y: this.pos.y, age: 1.0});

                // Move
                const moveSpeed = this.isPlayer ? this.speed : this.speed * gameState.timeScale;
                this.pos = this.pos.add(this.dir.mult(moveSpeed * dt));

                // Fade trails
                for(let i=0; i<this.trail.length; i++) {
                    this.trail[i].age -= 5 * dt;
                }
                this.trail = this.trail.filter(t => t.age > 0);

                // Bounds check
                if (this.pos.x < 0 || this.pos.x > width || this.pos.y < 0 || this.pos.y > height) {
                    this.active = false;
                }

                // Collisions
                if (this.isPlayer) {
                    // Hit Enemy
                    for (let e of enemies) {
                        if (e.pos.sub(this.pos).mag() < e.radius + 5) {
                            e.hp--;
                            this.active = false;
                            createParticles(this.pos.x, this.pos.y, 10, '#8a0303', 3); // Blood
                            if (e.hp <= 0) {
                                // Enemy Death
                                gameState.score += 15;
                                gameState.deadEyeMeter = Math.min(MAX_DEAD_EYE, gameState.deadEyeMeter + DEAD_EYE_GAIN);
                                updateUI();
                            }
                            break;
                        }
                    }
                    // Hit Props
                    for (let p of props) {
                        if (checkRectCollide(this.pos, p)) {
                            this.active = false;
                            createParticles(this.pos.x, this.pos.y, 5, '#deb887', 2); // Wood/Dust
                            break;
                        }
                    }
                } else {
                    // Hit Player
                    if (player.pos.sub(this.pos).mag() < player.radius + 5) {
                        player.hp -= 15; // Damage
                        this.active = false;
                        createParticles(this.pos.x, this.pos.y, 10, '#8a0303', 3);
                        screenShake(10);
                        updateUI();
                        if (player.hp <= 0) gameOver();
                    }
                     // Hit Props
                     for (let p of props) {
                        if (checkRectCollide(this.pos, p)) {
                            this.active = false;
                            createParticles(this.pos.x, this.pos.y, 5, '#deb887', 2); 
                            break;
                        }
                    }
                }
            }

            draw() {
                ctx.fillStyle = this.isPlayer ? '#FFD700' : '#ccc';
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, 3, 0, Math.PI * 2);
                ctx.fill();

                // Draw trail
                ctx.beginPath();
                for(let t of this.trail) {
                    ctx.lineTo(t.x, t.y);
                }
                ctx.strokeStyle = `rgba(255, 255, 200, 0.3)`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        class Particle {
            constructor(x, y, color, speed) {
                this.pos = new Vector(x, y);
                this.vel = new Vector((Math.random()-0.5)*2, (Math.random()-0.5)*2).norm().mult(Math.random() * 50 * speed);
                this.life = 1.0;
                this.color = color;
            }
            update(dt) {
                this.pos = this.pos.add(this.vel.mult(dt * (gameState.deadEyeActive ? 0.5 : 1)));
                this.life -= 2 * dt;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.pos.x, this.pos.y, 3, 3);
                ctx.globalAlpha = 1.0;
            }
        }

        // --- Environment ---
        
        function generateTown() {
            props = [];
            // Saloon
            props.push({x: 100, y: 100, w: 200, h: 150, color: '#5D4037', label: "SALOON"});
            // Bank
            props.push({x: width - 300, y: 100, w: 200, h: 150, color: '#3E2723', label: "BANK"});
            // Troughs / Crates
            props.push({x: 400, y: 400, w: 50, h: 50, color: '#8B4513', label: ""});
            props.push({x: width - 400, y: 500, w: 60, h: 40, color: '#8B4513', label: ""});
        }

        function drawEnvironment() {
            // Ground Texture
            ctx.fillStyle = '#C2B280'; // Sand
            ctx.fillRect(0, 0, width, height);

            // Dust specs
            ctx.fillStyle = '#b0a070';
            for(let i=0; i<50; i++) {
                // Static noise simulation basically
                const x = (Math.sin(Date.now()*0.0001 + i)*width + width)%width;
                const y = (Math.cos(Date.now()*0.0001 + i)*height + height)%height;
                ctx.fillRect(x, y, 2, 2);
            }

            // Props
            props.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.w, p.h);
                // Roof detail
                ctx.strokeStyle = '#2c1b10';
                ctx.lineWidth = 4;
                ctx.strokeRect(p.x, p.y, p.w, p.h);
                
                // Text
                if (p.label) {
                    ctx.fillStyle = '#e0c0a0';
                    ctx.font = '20px Rye';
                    ctx.textAlign = 'center';
                    ctx.fillText(p.label, p.x + p.w/2, p.y - 10);
                }
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(p.x + 10, p.y + p.h, p.w - 10, 10);
            });
        }

        function checkRectCollide(point, rect) {
            return point.x >= rect.x && point.x <= rect.x + rect.w &&
                   point.y >= rect.y && point.y <= rect.y + rect.h;
        }

        // --- Core Logic ---

        function createParticles(x, y, count, color, speedMod) {
            for(let i=0; i<count; i++) {
                particles.push(new Particle(x, y, color, speedMod));
            }
        }

        function spawnWave() {
            const count = gameState.wave * 2 + 1;
            for(let i=0; i<count; i++) {
                // Spawn at edges
                let ex, ey;
                if (Math.random() > 0.5) {
                    ex = Math.random() > 0.5 ? -20 : width + 20;
                    ey = Math.random() * height;
                } else {
                    ex = Math.random() * width;
                    ey = Math.random() > 0.5 ? -20 : height + 20;
                }
                enemies.push(new Enemy(ex, ey));
            }
            
            const waveText = document.getElementById('center-msg');
            document.getElementById('msg-title').innerText = `WAVE ${gameState.wave}`;
            document.getElementById('msg-sub').innerText = "The Law is coming...";
            waveText.style.opacity = 1;
            setTimeout(() => waveText.style.opacity = 0, 2000);
        }

        let shakeTime = 0;
        let shakeAmount = 0;

        function screenShake(amount) {
            shakeAmount = amount;
            shakeTime = 0.2;
        }

        function toggleDeadEye() {
            if (gameState.deadEyeMeter > 10 && !gameState.deadEyeActive) {
                gameState.deadEyeActive = true;
                gameState.timeScale = 0.2; // Slow motion
                // Audio effect visual cue
                document.querySelector('.sepia-filter').style.backgroundColor = "rgba(255, 0, 0, 0.2)";
            } else {
                gameState.deadEyeActive = false;
                gameState.timeScale = 1.0;
                document.querySelector('.sepia-filter').style.backgroundColor = "rgba(112, 66, 20, 0.1)";
            }
        }

        function updateUI() {
            document.getElementById('score').innerText = gameState.score;
            document.getElementById('wave').innerText = gameState.wave;
            
            // Health Ring
            const healthRing = document.getElementById('health-ring');
            const dashOffset = 251 * (1 - Math.max(0, player.hp) / 100);
            healthRing.style.strokeDashoffset = dashOffset;

            updateAmmoUI();
        }

        function updateAmmoUI() {
            const container = document.getElementById('ammo-container');
            container.innerHTML = '';
            for(let i=0; i<player.ammo; i++) {
                const bullet = document.createElement('div');
                bullet.className = 'w-3 h-8 bg-[#DAA520] rounded-t-sm border border-yellow-800';
                container.appendChild(bullet);
            }
            if (player.ammo === 0) {
                const empty = document.createElement('span');
                empty.className = "text-red-500 font-bold";
                empty.innerText = "EMPTY";
                container.appendChild(empty);
            }
        }

        function gameOver() {
            gameState.gameOver = true;
            gameState.active = false;
            const msg = document.getElementById('center-msg');
            document.getElementById('msg-title').innerText = "DEAD";
            document.getElementById('msg-sub').innerText = `Bounty: $${gameState.score} - Click to Retry`;
            msg.style.opacity = 1;
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('center-msg').style.opacity = 0;
            
            player = new Player();
            bullets = [];
            enemies = [];
            particles = [];
            generateTown();

            gameState.hp = 100;
            gameState.score = 0;
            gameState.wave = 1;
            gameState.gameOver = false;
            gameState.active = true;
            gameState.deadEyeMeter = 50;
            gameState.timeScale = 1.0;
            
            spawnWave();
            updateUI();

            if (!gameLoopId) {
                lastTime = performance.now();
                gameLoop(lastTime);
            }
        }

        function gameLoop(timestamp) {
            gameLoopId = requestAnimationFrame(gameLoop);
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            if (!gameState.active) {
                // Draw background even if paused/gameover
                if (!gameState.gameOver) return;
            }

            // Update Dead Eye Logic
            if (gameState.active) {
                if (gameState.deadEyeActive) {
                    gameState.deadEyeMeter -= DEAD_EYE_DRAIN * dt;
                    if (gameState.deadEyeMeter <= 0) {
                        gameState.deadEyeMeter = 0;
                        toggleDeadEye();
                    }
                } else {
                    // Passive regen (slow)
                    gameState.deadEyeMeter = Math.min(MAX_DEAD_EYE, gameState.deadEyeMeter + 2 * dt);
                }
                // Update Bar
                const bar = document.getElementById('deadeye-bar');
                bar.style.width = `${gameState.deadEyeMeter}%`;
            }

            // Handle Screenshake
            ctx.save();
            if (shakeTime > 0) {
                shakeTime -= dt;
                const dx = (Math.random() - 0.5) * shakeAmount;
                const dy = (Math.random() - 0.5) * shakeAmount;
                ctx.translate(dx, dy);
            }

            // --- Draw World ---
            ctx.clearRect(0, 0, width, height);
            
            drawEnvironment();

            // Sort entities by Y for crude depth
            const entities = [...enemies, player].sort((a, b) => a.pos.y - b.pos.y);

            // Draw dead bodies or splatters (simple approach: particles handle this)
            
            // Update & Draw Particles (bottom layer)
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(dt);
                particles[i].draw();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }

            // Update & Draw Entities
            if (gameState.active) {
                player.update(dt);
                // Collisions with props
                props.forEach(p => {
                    // Very simple box collision push-out
                    if (player.pos.x > p.x - player.radius && player.pos.x < p.x + p.w + player.radius &&
                        player.pos.y > p.y - player.radius && player.pos.y < p.y + p.h + player.radius) {
                        // Determine closest edge and push out
                         const centerX = p.x + p.w/2;
                         const centerY = p.y + p.h/2;
                         const dx = player.pos.x - centerX;
                         const dy = player.pos.y - centerY;
                         if (Math.abs(dx) > Math.abs(dy)) {
                             player.pos.x = dx > 0 ? p.x + p.w + player.radius : p.x - player.radius;
                         } else {
                             player.pos.y = dy > 0 ? p.y + p.h + player.radius : p.y - player.radius;
                         }
                    }
                });
            }
            
            enemies.forEach(e => {
                if (gameState.active) e.update(dt);
            });
            enemies = enemies.filter(e => e.hp > 0);

            entities.forEach(e => {
                if (e.hp > 0) e.draw();
            });

            // Bullets
            bullets.forEach(b => {
                b.update(dt);
                b.draw();
            });
            bullets = bullets.filter(b => b.active);

            // Wave Logic
            if (gameState.active && enemies.length === 0) {
                gameState.wave++;
                gameState.score += 100; // Wave bonus
                spawnWave();
                updateUI();
            }

            ctx.restore();
        }

    </script>
</body>
</html>
