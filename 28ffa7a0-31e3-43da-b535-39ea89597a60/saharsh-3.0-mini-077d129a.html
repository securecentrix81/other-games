<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saharsh 3.0 Mini</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        * { box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0; padding: 0;
            background-color: #fafafa;
            min-height: 100vh;
            overflow: hidden;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed; inset: 0; background: #fff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 0.4s ease;
        }
        #loading-screen.hidden { opacity: 0; pointer-events: none; }

        .loading-icon {
            width: 48px; height: 48px;
            border: 3px solid #e0e0e0; border-top-color: #333; border-radius: 50%;
            animation: spin 0.8s linear infinite; margin-bottom: 24px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .loading-title { font-size: 1.25rem; font-weight: 600; color: #333; margin-bottom: 8px; }
        .loading-status { color: #666; font-size: 0.875rem; max-width: 300px; text-align: center; margin-bottom: 20px; }
        .loading-progress { width: 240px; height: 4px; background: #e0e0e0; border-radius: 2px; overflow: hidden; }
        .loading-progress-bar { height: 100%; background: #333; width: 0%; transition: width 0.3s ease; }

        /* Main Container */
        .container {
            max-width: 720px; margin: 0 auto; padding: 16px;
            height: 100vh; display: flex; flex-direction: column;
        }
        .header { display: flex; justify-content: space-between; align-items: center; padding: 8px 0 16px; }
        h1 { margin: 0; color: #333; font-size: 1.125rem; font-weight: 600; }

        .btn-clear {
            padding: 6px 12px; background: transparent; color: #666;
            border: 1px solid #ddd; border-radius: 6px; cursor: pointer;
            font-size: 0.8rem; transition: all 0.2s;
        }
        .btn-clear:hover { background: #f0f0f0; }

        /* Chat */
        #chat-box {
            flex: 1; overflow-y: auto;
            display: flex; flex-direction: column; gap: 12px; padding: 8px 0;
        }
        .message {
            max-width: 85%; padding: 10px 14px; border-radius: 16px;
            line-height: 1.55; word-wrap: break-word; font-size: 0.95rem;
        }
        .user-msg {
            align-self: flex-end; background: #333; color: #fff;
            border-bottom-right-radius: 4px;
        }
        .bot-msg {
            align-self: flex-start; background: #fff; color: #333;
            border: 1px solid #e5e5e5; border-bottom-left-radius: 4px;
        }

        /* Markdown inside bot messages */
        .bot-msg p { margin: 0 0 8px; }
        .bot-msg p:last-child { margin-bottom: 0; }
        .bot-msg ul, .bot-msg ol { margin: 8px 0; padding-left: 20px; }
        .bot-msg li { margin: 4px 0; }
        .bot-msg code {
            background: #f4f4f4; padding: 2px 5px; border-radius: 4px;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace; font-size: 0.85em;
        }
        .bot-msg pre {
            background: #1e1e1e; color: #d4d4d4; padding: 12px;
            border-radius: 8px; overflow-x: auto; margin: 8px 0;
        }
        .bot-msg pre code { background: none; padding: 0; color: inherit; }

        /* Think / Reasoning Blocks */
        .think-block {
            margin: 6px 0; border: 1px solid #e0e0e0; border-radius: 8px;
            overflow: hidden; background: #fafafa; font-size: 0.9em;
        }
        .think-toggle {
            display: flex; align-items: center; gap: 6px;
            padding: 8px 10px; cursor: pointer; user-select: none; color: #888;
        }
        .think-toggle:hover { background: #f0f0f0; }
        .think-icon { font-size: 0.65rem; transition: transform 0.2s; display: inline-block; }
        .think-block.expanded .think-icon { transform: rotate(90deg); }
        .think-content {
            display: none; padding: 10px 12px;
            border-top: 1px solid #e0e0e0; color: #555; background: #fff;
            white-space: pre-wrap; word-break: break-word;
        }
        .think-block.expanded .think-content { display: block; }

        /* Tool-specific styling inside think blocks */
        .think-block.tool-block { border-color: #c8e6c9; background: #f1f8e9; }
        .think-block.tool-block .think-toggle { color: #558b2f; }
        .think-block.tool-block .think-content { background: #f9fbe7; border-color: #c8e6c9; }

        /* Streaming spinner for active think block */
        .think-spinner {
            width: 14px; height: 14px; border: 2px solid #ccc; border-top-color: #888;
            border-radius: 50%; animation: spin 0.8s linear infinite; flex-shrink: 0;
        }

        /* Phase indicator (replaces think-indicator) */
        .phase-indicator {
            color: #888; font-size: 0.85em; padding: 8px 0;
            display: flex; align-items: center; gap: 8px;
        }
        .phase-indicator::before {
            content: ''; width: 14px; height: 14px;
            border: 2px solid #ddd; border-top-color: #888;
            border-radius: 50%; animation: spin 0.8s linear infinite;
        }

        /* Typing cursor */
        .typing-cursor::after {
            content: '▋'; animation: blink 1s step-end infinite; color: #999;
        }
        @keyframes blink { 50% { opacity: 0; } }

        /* Input Area */
        .input-area { display: flex; gap: 8px; padding-top: 12px; }
        #user-input {
            flex: 1; padding: 12px 16px; border: 1px solid #ddd;
            border-radius: 24px; font-size: 0.95rem; outline: none;
            transition: border-color 0.2s;
        }
        #user-input:focus { border-color: #999; }
        #send-btn {
            padding: 0 20px; background: #333; color: #fff; border: none;
            border-radius: 24px; cursor: pointer; font-size: 0.9rem;
            font-weight: 500; transition: background 0.2s;
        }
        #send-btn:hover { background: #444; }
        #send-btn:disabled { background: #ccc; cursor: not-allowed; }
        #send-btn.stop { background: #c0392b; }
        #send-btn.stop:hover { background: #a93226; }

        .empty-state {
            flex: 1; display: flex; align-items: center;
            justify-content: center; color: #aaa;
        }
    </style>
</head>
<body>

<!-- Loading Screen -->
<div id="loading-screen">
    <div class="loading-icon"></div>
    <div class="loading-title">Saharsh 3.0 Mini</div>
    <div class="loading-status" id="loading-status">Initializing...</div>
    <div class="loading-progress">
        <div class="loading-progress-bar" id="loading-progress-bar"></div>
    </div>
</div>

<!-- Main Container -->
<div class="container" id="main-container" style="display: none;">
    <div class="header">
        <h1>Saharsh 3.0 Mini</h1>
        <button class="btn-clear" id="clear-btn">Clear</button>
    </div>
    <div id="chat-box">
        <div class="empty-state" id="empty-state">Send a message to start</div>
    </div>
    <div class="input-area">
        <input type="text" id="user-input" placeholder="Type a message..." />
        <button id="send-btn">Send</button>
    </div>
</div>

<script>addEventListener("error",(e)=>{alert(e.message)})</script>
<script type="module">
import { CreateMLCEngine } from "https://esm.run/@mlc-ai/web-llm";

// const SELECTED_MODEL = "Qwen3-1.7B-q4f16_1-MLC";
const SELECTED_MODEL = "Llama-3.2-3B-Instruct-q4f16_1-MLC"
/* ─── DOM refs ─── */
const loadingScreen    = document.getElementById('loading-screen');
const loadingStatus    = document.getElementById('loading-status');
const loadingBar       = document.getElementById('loading-progress-bar');
const mainContainer    = document.getElementById('main-container');
const chatBox          = document.getElementById('chat-box');
const userInput        = document.getElementById('user-input');
const sendBtn          = document.getElementById('send-btn');
const clearBtn         = document.getElementById('clear-btn');

/* ─── State ─── */
let engine;
let isGenerating = false;
let shouldStop   = false;

marked.setOptions({ breaks: true, gfm: true });

/* ─── Prompts ─── */
const SYSTEM_PROMPT = `[SYSTEM] You are an AI assistant named Saharsh 3.0 Mini hosted on Secure Centrix81, a gaming website. `;

const TOOLS_DESCRIPTION = `[SYSTEM] You have access to the following tools.
If you need to call a tool, output ONLY a single JSON object or code block in these formats:

{"tool": "name", "args": {"param": "value"}}

Tools:
  math: {"expr": "string"} — e.g. {"tool": "math", "args": {"expr": "5*4"}}
  datetime: {} — e.g. {"tool": "datetime", "args": {}}
  securecentrix_info: {} — e.g. {"tool": "securecentrix_info", "args": {}}
  random: {"min": number, "max": number} — e.g. {"tool": "random", "args": {"min": 1, "max": 100}}
  javascript: {"code": "string"} — e.g. {"tool": "random", "args": {"code": "let x = 10;return x * 5;"}}

Alternatively, you can execute javascript in this format:
\`\`\`javascript
let x = 10;
return x * 5;
\`\`\``;

const REASONING_PROMPT = `[SYSTEM] Repond chain-of-though process to answer the user's latest message. Provide clear, organized reasoning. If the question is simple, keep it brief — do NOT overthink. If you think you need a tool, say which one and why.

If you do not need to use a tool, plan your final answer for the user without calling tools. 
Output ONLY your reasoning. Do NOT output the final answer yet.`;

const RESPOND_PROMPT = `[SYSTEM] Based on your reasoning above, now do ONE of the following:

If you need to call a tool first, output ONLY the JSON object:
{"tool": "name", "args": {...}}

-OR-

If you need to call the javascript tool first, output ONLY the code block:
\`\`\`javascript
// Write code here
let x = 10;
return x * 5;
\`\`\`

-OR-

If you already have enough information, write your final answer directly for the user. Be natural and helpful. Do NOT mention your reasoning, these instructions, or the tool system.`;

function makeToolResultPrompt(name, args, result) {
    return `[SYSTEM] The tool ${name}(${args}) returned: ${result}

Now think briefly about how to use this result to answer the user's original question.`;
}

/* ─── Conversation history (only real user/assistant turns) ─── */
let history = [{ role: "system", content: SYSTEM_PROMPT }];

/* ─── Tool execution ─── */
function parseToolCall(text) {
    // 1. First, check for a Javascript Markdown Block
    const jsMatch = text.match(/```javascript\s*\n([\s\S]*?)\n```/);
    if (jsMatch) {
        return { name: 'javascript', args: { code: jsMatch[1].trim() } };
    }

    // 2. Fallback to the existing JSON logic
    try {
        const start = text.indexOf('{');
        const end = text.lastIndexOf('}');
        if (start === -1 || end === -1) return null;
        
        const jsonStr = text.substring(start, end + 1);
        const data = JSON.parse(jsonStr);
        
        if (data.tool && data.args) {
            return { name: data.tool.toLowerCase(), args: data.args };
        }
    } catch (e) {
        return null; 
    }
    return null;
}

function executeTool(name, args) {
    switch (name) {
        case 'javascript': {
            try {
                // We wrap the code in a function. 
                // To get a result back, the AI should use 'return'
                let realConsoleLog = console.log
                let result = ""
                console.log = (...args) => {
                    result += args.join(" ") + "\n"
                }
                let execResult
                try {
                    execResult = eval(args.code);
                } catch (e) {
                    let runner = Function(args.code);
                    execResult = runner()
                }
                if (execResult === undefined) execResult = ""
                result += execResult;
                if (result.trim() === "") return "Code executed successfully (no return value)";
                return String(result)
            } catch (e) {
                return e.message;
            }
        }
        case 'math': {
            try {
                const expr = args.expr.replace(/\^/g, '**'); // Access .expr
                const round = Math.round
                const floor = Math.floor
                const ceil = Math.ceil
                const sqrt = Math.sqrt
                const sin = Math.sin
                const cos = Math.cos
                const pi = Math.PI
                const PI = Math.PI
                const e = Math.E
                const E = Math.E
                const cbrt = Math.cbrt
                const abs = Math.abs
                const asin = Math.asin
                const acos = Math.acos
                const acosh = Math.acosh
                const asinh = Math.asinh
                const atan = Math.atan
                const atanh = Math.atanh
                const cosh = Math.cosh
                const exp = Math.exp
                const ln = Math.log
                const log = Math.log10
                const log2 = Math.log2
                const log10 = Math.log10
                const max = Math.max
                const min = Math.min
                const pow = Math.pow
                const tan = Math.tan
                const tanh = Math.tanh
                const random = Math.random
                let val
                try {
                    val = eval('return (' + expr + ')');
                } catch (e) {
                    const runner = Function('return (' + expr + ')');
                    val = runner()
                }
                return String(val);
            } catch (e) { return "Error: " + e.message; }
        }
        case 'datetime':
            return new Date().toLocaleString();
        case 'random': {
            const lo = parseInt(args.min); // Access .min
            const hi = parseInt(args.max); // Access .max
            if (!isNaN(lo) && !isNaN(hi)) {
                const min = Math.min(lo, hi);
                const max = Math.max(lo, hi);
                return String(Math.floor(Math.random() * (max - min + 1)) + min);
            }
            return "Error: use args {min: number, max: number}";
        }
        case 'securecentrix_info': {
            switch (args.page) {
                case "webretro": return "Webretro is an open-source port of the RetroArch emulator frontend to WebAssembly (WASM) using Emscripten. It allows users to play classic console games (NES, SNES, Genesis, GBA) directly in a web browser. Key features include save state management, support for various controllers, and in-browser ROM loading. It can be accessed on Secure Centrix81 via the url https://securecentrix81.github.io/webretro"
                case "project-hub": return `Project Hub v2 can be accessed at https://securecentrix81.github.io/project-hub-v2. See {"page":"project-hub-list"} for an extensive list of games hosted on project-hub-v2.`
                case "project-hub-list": return `1v1.lol
2048
Ace Attorney
Animal Crossing: Wild World
Animator Vs Animation
Basketball Stars
BitLife
Block Blast
Bloons TD 1,2,5
Bloxorz
Breaking the Bank
Cookie Clicker
Cooking Mama 1,2,3
Craftmine
Crossy Road
Cut the Rope
- Holiday Gift
- Time Travel
DELTARUNE
Douchebag Life
Douchebag Workout 2
Draw the Hill
Duck Life 1,2,3,4
Dune
Escaping the Prison
Flappy Bird
Fleeing the Complex
FNAF 1,2,3,UCN,World
Friday Night Funkin'
Fruit Ninja
Google Dino
Happy Wheels
Hextris
Hollow Knight
Infiltrating the Airship
Infinite Mario Bros
Interactive Buddy
Jetpack Joyride
Learn to Fly 1,2
Madalin Stunt Cars 2,3
Minecraft: Classic
Mini Putt
MotoX3M 1,2
Monster High - Ghoul Spirit
N-Gon
Pandemic 2
Papa's:
- Bakeria
- Burgeria
- Cheeseria
- Donuteria
- Freezeria
- Pancakeria
- Pastaria
- Pizzeria
- Sushiria
Paper.io 2
Papery Planes
Pokemon:
- Emerald
- Pearl
- Fire Red
Portal: Flash
Red Ball 4
Resent Client
Retro Bowl
Riddle School 1,2,3,4,5
Riddle Transfer 1,2
Rocket Soccer
Saharsh Gobinath Clicker (famous)
Rolly Vortex
Sand Game
Slope
Solitaire
Sonic: Flash
Stack
Stealing the Diamond
Stickman Hook
Storm the House 2
Subway Surfers:
- San Francisco
- Zurich
Superhot
Super Mario 64
Super Scribblenauts
Super Smash Flash
Tanuki Sunset
Temple Run 2
Tetris
The Binding of Isaac
The Impossible Quiz
There Is No Game
Townscaper
Transcube
UNDERTALE
UNDERTALE: Yellow
Vex 4,5,6
Wordle
World's Hardest Game 1,2`
                case "turbowarp-links": return `Turbowarp is Scratch compiler that lets them run over ten times as fast as they normally would. The list of games can be accessed at https://securecentrix81.github.io/turbowarp-links, and the actual turbowarp compiler can be accessed at https://securecentrix81.github.io/turbowarp. List of games: Vectoid TD 3D v1.4
Navier Stokes Fluid Simulation
Knotted
The Mast [3D]
osu! Full Remake
Submersible
3D Tearable Cloth
Scratch Bloons TD
Terraria
2D Physics Engine
Rope Physics
Sand and Water
Portal 3D Test Chamber 13
Chess AI
Appel v1.4
Appel Multiplayer v2.0`
                case "gfiles": return `Gfiles is a public HTML5 Game Archive made by SevenworksDev. Gfiles can be accessed at https://securecentrix81.github.io/gfiles/. Credit goes to https://github.com/HTML5GameArchive/gfiles for making this. See {"page":"gfiles-list"} for a very long list of games.`
                case "gfiles-list": return `# games
1v1lol
2048
adarkroom
asciispace
assessmentexamination
asteroids
astray
backcountry
baldisbasics
basketballlegends
basketballstars
basketbrosio
basketrandom
bitlife
blackholesquare
bounceback
boxingrandom
breaklock
breakout
btd4
captaincallisto
chess
chromaincident
chromedino
clickerheroes
clusterrush
connect3
cookieclicker
crossyroad
csgoclicker
cubefield
cubitomayhem
cuttherope
cuttheropeholiday
cuttheropetimetravel
deathrun3d
deepestsword
doodlejump
doom
drawthehill
drift
drifthunters
drivemad
ducklife
ducklife2
ducklife3
ducklife4
ducklife5
earntodie
edgenotfound
eggycar
evilglitch
factoryballsforever
fireboyandwatergirlforesttemple
flappy2048
flappybird
flappyplane
flightsimulator
fridaynightfunkin
friendlyfire
fruitninja
geometrydash
getawayshootoutnew
gladihoppers
googlesnake
gopherkart
grindcraft
hexgl
hextris
highwaytraffic
konnekt
learntofly
letssurf
littlealchemy
mergeroundracers
monkeymart
motoroadrash3d
motox3m
ninjavsevilcorp
omnombounce
ovo
ovo2
packabunchas
pacman
paperio
particleclicker
pushback
q1k3
r3
racer
radiusraid
redball4
retrobowl
retrohaunt
riddleschool2
ritz
roadblocks
rooftopsnipers
run3
scrapmetal3
shuttledeck
sketchbook04
sleepingbeauty
slitherio
slope
slope2
snake
snowbattle
soccerrandom
solitaire
spacecompany
spacegarden
spacehuggers
spaceinvaders
stack
stackball
stickman-hook
stickmanboost
stickmanclimb
stickmangolf
stickmanhook
stickmansurvival
subwaysurfers
subwaysurfersny
subwaysurferssingapore
tanukisunset
tetris
themazeofspacegoblins
timeshooter
timeshooter2
timeshooter3
tinyfishing
tombofthemask
topspeedracing3d
towermaster
trimps
tunnelrush
vex3
vex4
vex5
vex6
webecomewhatwebehold
worldshardestgame2
xx142b2exe
zombsroyale
# Emulators
ruffle retroarch`
                case "other-games": return `The "Other games" section can be accessed at https://securecentrix81.github.io/other-games. It contains a game request form https://forms.gle/aR7bQ4U1szfQNqKn9 and multiple user-requested games. The game request form allows for people to request for AI-generated games, or to import pre-made games. You do not have access to the full list of games hosted on Secure Centrix81. The user must visit https://securecentrix81.github.io/other-games in order to view them.`
                case "giveaway": return `There is a ongoing giveaway of ${window.usDebtFormatted} on Secure Centrix81. Giveaways can be accessed from the bottom of the page at: https://securecentrix81.github.io/securecentrix81. To be elegible for the giveaway, the user must complete an exhaustive 155-step guide that outlines a journey required to claim the giveaway, which frames the entire history of the universe and human progress as essential prerequisites for a single internet transaction. The process begins with the primordial necessity of existing as matter and surviving the formation of the solar system, then traces biological evolution from the first self-replicating RNA through the development of mammalian traits and human cognition. It proceeds to demand the mastery of every major human milestone, including the Agricultural Revolution, metallurgy, the invention of calculus, and the Industrial Revolution, leading into the complex development of semiconductor physics and the manual construction of a modern web browser from scratch. `
                default: `Error: unknown page "${args.page}"`
            }
            return `Secure Centrix81 is an advanced gaming website that specializes in security. It can be accessed at https://securecentrix81.github.io. Secure Centrix81 has the following games:
- Saharsh Gobinath Clicker: a fun, addicting game based on the fictional character "Saharsh Gobinath," a person who fails all of his classes and gets in trouble
- webretro: a browser-based front-end emulator (use the argument {"page":"webretro"} to see more)
- project-hub-v2: a list of games (see "project-hub")
- turbowarp-links: a list of scratch games (see "turbowarp-links")
- gfiles: a list of games (see "gfiles")
- polytrack: a web-based racing game inspired by TrackMania
- Madalin Stunt Cars: a multiplayer 3d stunt driving game(features version 2 and 3)
- other games: a Game Request form, with a long list of user-created games (see "other-games")
- money giveaway(${window.usDebtFormatted}, see "giveaway")`
        }
        default:
            return "Error: unknown tool '" + name + "'";
    }
}

/* ─── Streaming helper ─── */
async function streamGenerate(msgs, onToken, temp=0.7) {
    let text = "";
    const stream = await engine.chat.completions.create({
        messages: msgs,
        stream: true,
        max_tokens: 1024,
        temperature: temp,
        top_p: 0.9,
        chat_template_kwargs: { enable_thinking: false },
    });
    for await (const chunk of stream) {
        if (shouldStop) break;
        text += chunk.choices[0]?.delta?.content || "";
        if (onToken) onToken(text);
    }
    if (shouldStop) throw { stopped: true };
    return text;
}

/* ─── Display helpers ─── */
function scrollBottom() { chatBox.scrollTop = chatBox.scrollHeight; }

function createThinkBlockEl(label, content, expanded, isLive) {
    const block = document.createElement('div');
    block.className = 'think-block' + (expanded ? ' expanded' : '');
    if (label.startsWith('Tool:')) block.classList.add('tool-block');

    const toggle = document.createElement('div');
    toggle.className = 'think-toggle';

    if (isLive) {
        const spinner = document.createElement('span');
        spinner.className = 'think-spinner';
        toggle.appendChild(spinner);
    } else {
        const icon = document.createElement('span');
        icon.className = 'think-icon';
        icon.textContent = '▶';
        toggle.appendChild(icon);
    }
    const lbl = document.createElement('span');
    lbl.textContent = ' ' + label;
    toggle.appendChild(lbl);
    toggle.onclick = () => block.classList.toggle('expanded');

    const body = document.createElement('div');
    body.className = 'think-content';
    body.textContent = content;               // plain text during streaming
    if (!isLive) body.innerHTML = marked.parse(content);  // markdown after done

    block.appendChild(toggle);
    block.appendChild(body);
    return block;
}

/** Rebuild the bot bubble during streaming */
function renderLive(container, steps, phase, streamText) {
    container.innerHTML = '';

    // Completed reasoning/tool steps → collapsed blocks
    steps.forEach(s => {
        container.appendChild(createThinkBlockEl(s.label, s.content, false, false));
    });

    if (phase === 'thinking') {
        if (streamText) {
            container.appendChild(createThinkBlockEl('Thinking…', streamText, true, true));
        } else {
            const ind = document.createElement('div');
            ind.className = 'phase-indicator';
            ind.textContent = 'Thinking…';
            container.appendChild(ind);
        }
    } else if (phase === 'responding') {
        if (streamText) {
            const div = document.createElement('div');
            div.className = 'typing-cursor';
            div.textContent = streamText;      // plain text while streaming
            container.appendChild(div);
        } else {
            const ind = document.createElement('div');
            ind.className = 'phase-indicator';
            ind.textContent = 'Composing response…';
            container.appendChild(ind);
        }
    }
}

/** Final render with markdown + KaTeX */
function renderFinal(container, steps, response) {
    container.innerHTML = '';

    steps.forEach(s => {
        container.appendChild(createThinkBlockEl(s.label, s.content, false, false));
    });

    if (response) {
        const div = document.createElement('div');
        div.innerHTML = marked.parse(response);
        container.appendChild(div);
        if (typeof renderMathInElement === 'function') {
            renderMathInElement(div, {
                delimiters: [
                    { left: '$$',  right: '$$',  display: true  },
                    { left: '$',   right: '$',   display: false },
                    { left: '\\[', right: '\\]', display: true  },
                    { left: '\\(', right: '\\)', display: false },
                ],
                throwOnError: false,
            });
        }
    }
}

/* ─── Multi-pass reasoning pipeline ─── */
async function reasonAndRespond(container) {
    const steps = [];                       // { label, content }
    let workMsgs = [...history];            // copy — don't pollute real history
    const MAX_TOOL_ROUNDS = 100;

    /* ── Pass 1 : Reasoning ── */
    workMsgs.push({ role: "user", content: TOOLS_DESCRIPTION });
    workMsgs.push({ role: "user", content: REASONING_PROMPT });
    
    renderLive(container, steps, 'thinking', '');

    let reasoning = await streamGenerate(workMsgs, txt => {
        renderLive(container, steps, 'thinking', txt);
        scrollBottom();
    }, 0.2);
    workMsgs.push({ role: "assistant", content: reasoning });
    steps.push({ label: 'Reasoning', content: reasoning });

    /* ── Pass 2+ : Respond / tool loop ── */
    let finalResponse = "";

    for (let round = 0; round < MAX_TOOL_ROUNDS; round++) {
        workMsgs.push({ role: "user", content: RESPOND_PROMPT });
        renderLive(container, steps, 'responding', '');

        let response = await streamGenerate(workMsgs, txt => {
            renderLive(container, steps, 'responding', txt);
            scrollBottom();
        }, 0.8);
        workMsgs.push({ role: "assistant", content: response });

        const tool = parseToolCall(response);
        if (tool) {
            /* ── Execute tool ── */
            const result = executeTool(tool.name, tool.args);
            
            // Create a version of the result for the UI (redacted if it's the info tool)
            const displayResult = (tool.name === 'securecentrix_info') 
                ? "Data retrieved from Secure Centrix81 database." 
                : result;
            
            steps.push({
                label: `Tool: ${tool.name}`,
                content: `Called: ${tool.name}\nArgs: ${JSON.stringify(tool.args)}\nResult: ${displayResult}`
            });
            
            /* ── Feed REAL result back to the AI (not the redacted one) ── */
            workMsgs.push({
                role: "user",
                content: makeToolResultPrompt(tool.name, tool.args, result)
            });
            renderLive(container, steps, 'thinking', '');

            let postToolReasoning = await streamGenerate(workMsgs, txt => {
                renderLive(container, steps, 'thinking', txt);
                scrollBottom();
            });
            workMsgs.push({ role: "assistant", content: postToolReasoning });
            steps.push({ label: 'Reasoning', content: postToolReasoning });

        } else {
            /* ── No tool call → this is the final answer ── */
            finalResponse = response;
            break;
        }
    }

    if (!finalResponse) {
        finalResponse = "Sorry, I couldn't finish processing. Please try rephrasing.";
    }

    renderFinal(container, steps, finalResponse);
    return finalResponse;
}

/* ─── Send message ─── */
async function sendMessage() {
    const text = userInput.value.trim();
    if (!text || isGenerating) return;

    const empty = document.getElementById('empty-state');
    if (empty) empty.style.display = 'none';

    appendUserBubble(text);
    userInput.value = '';

    isGenerating = true;
    shouldStop = false;
    sendBtn.textContent = 'Stop';
    sendBtn.classList.add('stop');
    userInput.disabled = true;

    history.push({ role: "user", content: "[USER]:\n"+text });

    const botDiv = document.createElement('div');
    botDiv.className = 'message bot-msg';
    chatBox.appendChild(botDiv);
    scrollBottom();

    try {
        const finalText = await reasonAndRespond(botDiv);
        history.push({ role: "assistant", content: finalText });
    } catch (e) {
        if (!e.stopped) {
            botDiv.textContent = "Error: " + (e.message || e);
        }
    } finally {
        isGenerating = false;
        sendBtn.textContent = 'Send';
        sendBtn.classList.remove('stop');
        userInput.disabled = false;
        userInput.focus();
        scrollBottom();
    }
}

function appendUserBubble(text) {
    const div = document.createElement('div');
    div.className = 'message user-msg';
    div.textContent = text;
    chatBox.appendChild(div);
    scrollBottom();
}

function clearChat() {
    history = [{ role: "system", content: SYSTEM_PROMPT }];
    chatBox.innerHTML = '<div class="empty-state" id="empty-state">Send a message to start</div>';
}

/* ─── Event listeners ─── */
sendBtn.onclick = () => {
    if (isGenerating) shouldStop = true;
    else sendMessage();
};
userInput.onkeypress = e => { if (e.key === 'Enter' && !isGenerating) sendMessage(); };
clearBtn.onclick = clearChat;

/* ─── Init ─── */
async function init() {
    try {
        loadingStatus.textContent = "Downloading model…";
        engine = await CreateMLCEngine(SELECTED_MODEL, {
            initProgressCallback: (progress) => {
                loadingBar.style.width = Math.ceil(progress.progress * 100) + '%';
                loadingStatus.textContent = progress.text;
            }
        });
        loadingScreen.classList.add('hidden');
        mainContainer.style.display = 'flex';
        userInput.focus();
    } catch (err) {
        loadingStatus.textContent = "Error: " + err.message;
        loadingBar.style.background = '#c0392b';
    }
}

init();
</script>
    <script>
        window.usDebtFormatted = "$38422818570606.64"
    let moneyTarget = 38422818570606.64;
      let currentMoney = 38422818570606.64;
      let growthRatePerMs = 201.651206792806;
      let baseDebt = 38490798138585.9;
      let baseTime = 1769040000000;
      const apiUrl = 'https://api.fiscaldata.treasury.gov/services/api/fiscal_service/v2/accounting/od/debt_to_penny?sort=-record_date&page[size]=2';

      const formatter = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      });

      async function fetchDebt() {
        try {
          const response = await fetch(apiUrl);
          const data = await response.json();
          const latest = data.data[0];
          const previous = data.data[1];
          const d1 = parseFloat(latest.tot_pub_debt_out_amt);
          const d2 = parseFloat(previous.tot_pub_debt_out_amt);
          const t1 = new Date(latest.record_date).getTime();
          const t2 = new Date(previous.record_date).getTime();
          growthRatePerMs = (d1 - d2) / (t1 - t2);
          baseDebt = d1;
          baseTime = t1;
          currentMoney = Math.max(d1, currentMoney);
          moneyTarget = d1;
        } catch (error) {
          console.error('Error fetching debt data:', error);
        }
      }

      function simulateLiveTarget() {
        if (baseTime > 0) {
          const msElapsedSinceRecord = Date.now() - baseTime;
          moneyTarget = baseDebt + (growthRatePerMs * msElapsedSinceRecord);
        }
      }

      function updateDebt() {
        simulateLiveTarget();
        currentMoney += (moneyTarget - currentMoney) * 0.05;
        const formatted = formatter.format(currentMoney);
          window.usDebtFormatted = formatted
        for (let i of document.querySelectorAll('.us-debt')) {
          i.innerText = formatted;
        }
        requestAnimationFrame(updateDebt);
      }

      updateDebt();
      fetchDebt();
      setInterval(fetchDebt, 1000 * 30);
    </script>
</body>
</html>
